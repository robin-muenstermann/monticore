{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MontiCore - Language Workbench And Development Tool Framework MontiCore is a language workbench for an efficient development of domain-specific languages (DSLs). It processes an extended grammar format which defines the DSL and generates Java components for processing the DSL documents. Examples for these components are parser, AST classes, symboltables or pretty printers. This enables a user to rapidly define a language and use it together with the MontiCore-framework to build domain specific tools. Some MontiCore advantages are the reusability of predefined language components, conservative extension and composition mechanisms and an optimal integration of hand-written code into the generated tools. Its grammar languages are rather comfortable. A Teaser for MontiCore To show a little of MontiCore's capabilities, the following (incomplete) grammar might help: grammar MyStatemachine extends Automata, // MontiCore grammar MCBasicTypes, SetExpressions, MCCommonLiterals { start Automaton; // overriding a nonterminal (to add optional conditions): Transition = from:Name@State \":\" Expression? \"->\" to:Name@State; // add new variants of expressions LogicalNotExpr implements Expression = \"!\" Expression; XorExpr implements Expression = left:Expression \"xor\" right:Expression; scope LetExpr implements Expression = \"let\" (VarDeclaration || \",\")+ \"in\" Expression; symbol VarDeclaration = MCType? Name \"=\" Expression ; } The grammar language has a variety of mechanisms to define new nonterminals using constants \"!\" , brackets (..) , optionals ? , lists * , repetitions (..||..)+ , etc. The grammar builds an extended version of Statemachines reusing existing grammar components, here Automata , MCBasicTypes , SetExpressions and MCCommonLiterals . The grammar has 5 productions introducing 4 new nonterminals and overrides Transition , which is inherited from Automata . Transition additionally has an optional Expression? as firing condition. LogicalNotExpr , XorExpr , and LetExpr extend the already existing Expression nonterminal and add new forms of expressions. LetExpr introduces a new local variable, which is visible only in that scope (indicated by keyword). VarDeclaration defines the new place to define symbols (that have a Name ). There is an extensive infrastructure to manage the definition of names, visibility, etc. MontiCore compiles the above grammar into 78 classes with in total 18629 lines of code that define the complete frontend and a larger part of the backend of a statemachine processor. We now can write statemachines like: statemachine PingPong { // MyStatemachine state Ping, Pong; Ping : (speed > 14km/h && !missedBall) -> Pong } MontiCore provides versions of expressions that use SI Units like 240km/h or 14.2 m/s^2 , but also Java expressions like 2_000_000 and other variants including appropriate type checks. We include these forms of expressions by importing their grammars. Please note that in both cases (extension and overwriting existing nonterminals), we do not touch nor copy/paste the predefined grammars, but achieve an out-of-the-box reuse. Out-of-the-box reuse also includes reuse of predefined typechecks, code generation, etc. They only need to be extended to the added variants. Please also note that PlusExpr is mutually left-recursive. -- Yes, that works in MontiCore 6. More Information about MontiCore MontiCore Online Demonstrator . (TODO: needs to be released) MontiCore Reference Manual . The reference Manual describes how to use MontiCore as a out-of-the-box language workbench ), but also as grey box tooling framework . It thus also gives an overview over a number of core mechanisms of MontiCore. List of core grammars . MontiCore concentrates on reuse. It therefore offers a set of predefined language components , usually identified through an appropriate component grammar allowing to define your own language as a composition of reusable assets efficiently. reusable assets are among others: several sets of literals , expressions , types , and statements , which are freely composable. List of languages . This is a list of languages that can be used out of the box. Some of them are in development, others rather stable. Several of these languages are inspired by the UML/P (see [Rum16,Rum17] . These complete languages are usually composed of a number of language components. MontiCore 3-Level License on files (informal description) Summary: This project is freely available software; you can redistribute the MontiCore language workbench according to the following rules. Details: The MontiCore Languag Workbench deals with three levels of code (MontiCore, tool derivates, product code). Each with different licenses: Product code : when you use a MontiCore tool derivate to generate code, the generated code is absolutely free for each form of use including commercial use without any license. Tool derivate : when you derive a tool using the MontiCore language workbench, then you mention that it is a MontiCore derivate. There is no other restriction. (BSD 3 Clause license) MontiCore adaptations : you may also freely adapt MontiCore itself, but then you have to mention MontiCore AND the resulting code is to be pushed back into this LPGL repository (LGPL license). As a consequence using MontiCore during development is rather flexible and the final products do not have any restriction. If questions appear e.g. on building an interpreter, please contact monticore@se-rwth.de. General disclaimer (Repeated from the the BSD 3 Clause license): This software is provided by the copyright holders and contributors \"as is\" and any expressed or implied warranties, including, but not limited to, the implied warranties of merchantability and fitness for a particular purpose are disclaimed. In no event shall the copyright holder or contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of substitute goods or services; loss of use, data, or profits; or business interruption) however caused and on any theory of liability, whether in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage. Included Software This product includes the following software: * AntLR * FreeMarker Contribution When you want to contribute: Please make sure that your complete workspace only uses UNIX line endings (LF) and all files are UTF-8 without BOM. On Windows you should configure git to not automatically replace LF with CRLF during checkout by executing the following configuration: git config --global core.autocrlf input Further Information see also MontiCore Reference Manual MontiCore Reference Languages - Languages Built Using MontiCore Build MontiCore - How to Build MontiCore Getting Started - How to Build MontiCore Changelog - Release Notes FAQ - FAQ Licenses - MontiCore 3-Level License","title":"Home"},{"location":"#monticore-language-workbench-and-development-tool-framework","text":"MontiCore is a language workbench for an efficient development of domain-specific languages (DSLs). It processes an extended grammar format which defines the DSL and generates Java components for processing the DSL documents. Examples for these components are parser, AST classes, symboltables or pretty printers. This enables a user to rapidly define a language and use it together with the MontiCore-framework to build domain specific tools. Some MontiCore advantages are the reusability of predefined language components, conservative extension and composition mechanisms and an optimal integration of hand-written code into the generated tools. Its grammar languages are rather comfortable.","title":"MontiCore - Language Workbench And Development Tool Framework"},{"location":"#a-teaser-for-monticore","text":"To show a little of MontiCore's capabilities, the following (incomplete) grammar might help: grammar MyStatemachine extends Automata, // MontiCore grammar MCBasicTypes, SetExpressions, MCCommonLiterals { start Automaton; // overriding a nonterminal (to add optional conditions): Transition = from:Name@State \":\" Expression? \"->\" to:Name@State; // add new variants of expressions LogicalNotExpr implements Expression = \"!\" Expression; XorExpr implements Expression = left:Expression \"xor\" right:Expression; scope LetExpr implements Expression = \"let\" (VarDeclaration || \",\")+ \"in\" Expression; symbol VarDeclaration = MCType? Name \"=\" Expression ; } The grammar language has a variety of mechanisms to define new nonterminals using constants \"!\" , brackets (..) , optionals ? , lists * , repetitions (..||..)+ , etc. The grammar builds an extended version of Statemachines reusing existing grammar components, here Automata , MCBasicTypes , SetExpressions and MCCommonLiterals . The grammar has 5 productions introducing 4 new nonterminals and overrides Transition , which is inherited from Automata . Transition additionally has an optional Expression? as firing condition. LogicalNotExpr , XorExpr , and LetExpr extend the already existing Expression nonterminal and add new forms of expressions. LetExpr introduces a new local variable, which is visible only in that scope (indicated by keyword). VarDeclaration defines the new place to define symbols (that have a Name ). There is an extensive infrastructure to manage the definition of names, visibility, etc. MontiCore compiles the above grammar into 78 classes with in total 18629 lines of code that define the complete frontend and a larger part of the backend of a statemachine processor. We now can write statemachines like: statemachine PingPong { // MyStatemachine state Ping, Pong; Ping : (speed > 14km/h && !missedBall) -> Pong } MontiCore provides versions of expressions that use SI Units like 240km/h or 14.2 m/s^2 , but also Java expressions like 2_000_000 and other variants including appropriate type checks. We include these forms of expressions by importing their grammars. Please note that in both cases (extension and overwriting existing nonterminals), we do not touch nor copy/paste the predefined grammars, but achieve an out-of-the-box reuse. Out-of-the-box reuse also includes reuse of predefined typechecks, code generation, etc. They only need to be extended to the added variants. Please also note that PlusExpr is mutually left-recursive. -- Yes, that works in MontiCore 6.","title":"A Teaser for MontiCore"},{"location":"#more-information-about-monticore","text":"MontiCore Online Demonstrator . (TODO: needs to be released) MontiCore Reference Manual . The reference Manual describes how to use MontiCore as a out-of-the-box language workbench ), but also as grey box tooling framework . It thus also gives an overview over a number of core mechanisms of MontiCore. List of core grammars . MontiCore concentrates on reuse. It therefore offers a set of predefined language components , usually identified through an appropriate component grammar allowing to define your own language as a composition of reusable assets efficiently. reusable assets are among others: several sets of literals , expressions , types , and statements , which are freely composable. List of languages . This is a list of languages that can be used out of the box. Some of them are in development, others rather stable. Several of these languages are inspired by the UML/P (see [Rum16,Rum17] . These complete languages are usually composed of a number of language components.","title":"More Information about MontiCore"},{"location":"#monticore-3-level-license-on-files-informal-description","text":"Summary: This project is freely available software; you can redistribute the MontiCore language workbench according to the following rules. Details: The MontiCore Languag Workbench deals with three levels of code (MontiCore, tool derivates, product code). Each with different licenses: Product code : when you use a MontiCore tool derivate to generate code, the generated code is absolutely free for each form of use including commercial use without any license. Tool derivate : when you derive a tool using the MontiCore language workbench, then you mention that it is a MontiCore derivate. There is no other restriction. (BSD 3 Clause license) MontiCore adaptations : you may also freely adapt MontiCore itself, but then you have to mention MontiCore AND the resulting code is to be pushed back into this LPGL repository (LGPL license). As a consequence using MontiCore during development is rather flexible and the final products do not have any restriction. If questions appear e.g. on building an interpreter, please contact monticore@se-rwth.de.","title":"MontiCore 3-Level License on files (informal description)"},{"location":"#general-disclaimer","text":"(Repeated from the the BSD 3 Clause license): This software is provided by the copyright holders and contributors \"as is\" and any expressed or implied warranties, including, but not limited to, the implied warranties of merchantability and fitness for a particular purpose are disclaimed. In no event shall the copyright holder or contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of substitute goods or services; loss of use, data, or profits; or business interruption) however caused and on any theory of liability, whether in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage.","title":"General disclaimer"},{"location":"#included-software","text":"This product includes the following software: * AntLR * FreeMarker","title":"Included Software"},{"location":"#contribution","text":"When you want to contribute: Please make sure that your complete workspace only uses UNIX line endings (LF) and all files are UTF-8 without BOM. On Windows you should configure git to not automatically replace LF with CRLF during checkout by executing the following configuration: git config --global core.autocrlf input","title":"Contribution"},{"location":"#further-information","text":"see also MontiCore Reference Manual MontiCore Reference Languages - Languages Built Using MontiCore Build MontiCore - How to Build MontiCore Getting Started - How to Build MontiCore Changelog - Release Notes FAQ - FAQ Licenses - MontiCore 3-Level License","title":"Further Information"},{"location":"00.org/Explanations/CHANGELOG/","text":"Release Notes MontiCore 6.0.0 Uses CD4Analysis 1.5.0 replace get*opt methods with get* bugfixing MontiCore 5.4.0.1 Uses CD4Analysis 1.4.0 add generation of serializers for grammars add SymbolLoader remove SymbolReferences add DeSers for TypeSymbols improved TypeCheck replace getName methods with printType methods MontiCore 5.3.0 Uses CD4Analysis 1.3.20.2 new Generator based on Decorator-Pattern add Translation classes add grammar it-tests move TypesCalculator to TypeCheck, create derive classes and synthesize classes add TypeSymbols and SymTypeExpression structure added DeSers for SymTypeExpressions added keyword \"key\" for KeyTerminals MontiCore 5.2.0 add \"List\"-Suffix to attribute name MontiCore 5.1.0 Remove the dependency to JavaDSL, add JavaLight Uses CD4Analysis 1.3.19 added grammar TypeSymbols renamed SymbolDelegateList to SymbolResolvingDelegateList add methods for scoperule-attributes in interfaces add MCTypeVisitor to transform ASTTypes to TypeExpressions add Groovy Plugin add MontiCore Statements at de.monticore.statements MontiCore 5.0.6 The IncGen-reports are stored in the source code directory Removed MutableScope IncGen-Reports are stored Removed deprecated keyword ast (use astrule ) in *.mc4 Add visitors for symbol table Enable TOP mechanism for visitors add SymbolRules and ScopeRules renamed MCBasicLiterals to MCCommonLiterals, add MCLiteralsBasis move literals to package de.monticore.literals renamed ShiftExpressions to BitExpressions MontiCore 5.0.3 Use the following emf coordinates (MB): group: org.eclipse.emf version: 2.15.0 artifact: org.eclipse.emf.ecore | org.eclipse.emf.ecore.xmi | org.eclipse.emf.common The runtime environment may need the following dependency (group: org.eclipse.platform; artifacitId: org.eclipse.equinox.common; version: 3.10.0) splitted Types.mc4 in MCBasicTypes, MCCollectionTypes, MCSimpleGenericTypes and MCFullGenericTypes moved expressions to de.monticore.expressions and added expressions MontiCore 5.0.2 Generated by the MontiCore version 5.0.1 Uses JavaDSL 4.3.13, Cd4Analysis 1.3.16, se-commons 1.7.9 Introduce deprecated annotation in grammars (#2215) Serialization of symobls Add reporter IncGenCheckReporter Configuration of the report path Specific resolving methods in generated scope classes Bugfixes MontiCore 5.0.1 Generated by the MontiCore version 5.0.0 Uses JavaDSL 4.3.12, Cd4Analysis 1.3.13, se-commons 1.7.9 Bugfixes New methods defineHookPointWithDefault in GlobalExtensionManagement (MB) new method cmpToken in MCParser (MB) every (non-)terminal defined in an interface must be present in the implementing production (including Name and Usage Name) (CoCo) (BS) to ensure that any terminal (with a specific name) has to be implemented, use an empty string, e.g. interface Expression = operator=\"\"; new methods are generated for the referenced symbol and definition and the definition is saved in an attribute (generated wenn you write sth. like \"Name@Symbol\") (NP) coco that gives a warning if you do not extend conservative (NP) coco that attributes with the same usage Name have to reference the same symbol (NP) SpannedScope and Symbol Methods in ASTNode set to deprecated (NP) MontiCore 5.0.0 Generated by the MontiCore version 4.5.5.1 Uses JavaDSL 4.3.11, Cd4Analysis 1.3.13, se-commons 1.7.8 Changed name building for list attributes in grammars (x:Name* -> getXList) Changed api for GlobalExtensionMangament and TemplateController (see reference manual) New api for AST nodes (constructor, getter and setter for lists and optional attributes, ...) Builder classes for AST nodes are external now. Signatures are similar to those in the corresponding AST node, except those methods which set or add something, these return the Builder itself (which allows method chaining) Changed default script to noemf for the generation of MontiCore. If you want to use emf you can generate monticore-grammar and Java-DSL with the profile \"emf\". This profile also creates the emf jars. You are also able to test the integration-tests with the profile \u201cemf-it-tests\u201d, which contains extra tests for the generation with emf. Parsed grammars are not stored as class diagram anymore. CD is only stored as report. Removed deprecated method filter(ResolvingInfo resolvingInfo, List symbols) use filter(ResolvingInfo, Collection) instead Removed deprecated method filter(ResolvingInfo resolvingInfo, String name, List symbols) use filter(ResolvingInfo, String, Map) instead Removed deprecated method create(Class symbolClass, SymbolKind symbolKind) use create(SymbolKind) instead Removed deprecated method getSymbols use getLocalSymbols instead Removed deprecated method resolve(SymbolPredicate predicate) use resolveMany(String, SymbolKind, Predicate) instead Removed deprecated method define use add instead Removed deprecated method resolve(ResolvingInfo resolvingInfo, String name, SymbolKind kind, AccessModifier modifier) Removed deprecated method checkIfContinueWithEnclosing use checkIfContinueWithEnclosingScope instead Removed deprecated method addResolver use addFilter(String, ResolvingFilter) instead Removed deprecated method addTopScopeResolver use addDefaultFilter instead Removed deprecated method addTopScopeResolvers use addDefaultFilters instead Removed deprecated method getTopScopeResolvingFilters use getDefaultFilters instead Removed deprecated constructer CommonResolvingFilter(Class symbolClass, SymbolKind targetKind) use CommonResolvingFilter(SymbolKind) instead Removed deprecated method continueWithScope and continueWithEnclosingScope Removed class FaildLoadingSymbol Removed deprecated method putInScopeAndLinkWithAst use addToScopeAndLinkWithNode instead Removed deprecated constructer CommonModelingLanguage(String, String, SymbolKind) use CommonModelingLanguage(String, String) instead Removed deprecated method addResolver use addResolvingFilter instead Removed deprecated method addResolver use addResolvingFilter instead Removed deprecated method getResolvers use getResolvingFilters instead Removed deprecated method loadAmbiguousModelAndCreateSymbolTable use loadModelsIntoScope instead Removed deprecated method loadAmbiguousModels use loadModels instead Removed deprecated method defineHookPoint(String) use glex.defineHookPoint instead Removed deprecated enum ParserExecution Removed deprecated method getParserTarget Removed deprecated method setParserTarget Further Information see also MontiCore Reference Manual MontiCore project - MontiCore","title":"Changelog"},{"location":"00.org/Explanations/CHANGELOG/#release-notes","text":"","title":"Release Notes"},{"location":"00.org/Explanations/CHANGELOG/#monticore-600","text":"Uses CD4Analysis 1.5.0 replace get*opt methods with get* bugfixing","title":"MontiCore 6.0.0"},{"location":"00.org/Explanations/CHANGELOG/#monticore-5401","text":"Uses CD4Analysis 1.4.0 add generation of serializers for grammars add SymbolLoader remove SymbolReferences add DeSers for TypeSymbols improved TypeCheck replace getName methods with printType methods","title":"MontiCore 5.4.0.1"},{"location":"00.org/Explanations/CHANGELOG/#monticore-530","text":"Uses CD4Analysis 1.3.20.2 new Generator based on Decorator-Pattern add Translation classes add grammar it-tests move TypesCalculator to TypeCheck, create derive classes and synthesize classes add TypeSymbols and SymTypeExpression structure added DeSers for SymTypeExpressions added keyword \"key\" for KeyTerminals","title":"MontiCore 5.3.0"},{"location":"00.org/Explanations/CHANGELOG/#monticore-520","text":"add \"List\"-Suffix to attribute name","title":"MontiCore 5.2.0"},{"location":"00.org/Explanations/CHANGELOG/#monticore-510","text":"Remove the dependency to JavaDSL, add JavaLight Uses CD4Analysis 1.3.19 added grammar TypeSymbols renamed SymbolDelegateList to SymbolResolvingDelegateList add methods for scoperule-attributes in interfaces add MCTypeVisitor to transform ASTTypes to TypeExpressions add Groovy Plugin add MontiCore Statements at de.monticore.statements","title":"MontiCore 5.1.0"},{"location":"00.org/Explanations/CHANGELOG/#monticore-506","text":"The IncGen-reports are stored in the source code directory Removed MutableScope IncGen-Reports are stored Removed deprecated keyword ast (use astrule ) in *.mc4 Add visitors for symbol table Enable TOP mechanism for visitors add SymbolRules and ScopeRules renamed MCBasicLiterals to MCCommonLiterals, add MCLiteralsBasis move literals to package de.monticore.literals renamed ShiftExpressions to BitExpressions","title":"MontiCore 5.0.6"},{"location":"00.org/Explanations/CHANGELOG/#monticore-503","text":"Use the following emf coordinates (MB): group: org.eclipse.emf version: 2.15.0 artifact: org.eclipse.emf.ecore | org.eclipse.emf.ecore.xmi | org.eclipse.emf.common The runtime environment may need the following dependency (group: org.eclipse.platform; artifacitId: org.eclipse.equinox.common; version: 3.10.0) splitted Types.mc4 in MCBasicTypes, MCCollectionTypes, MCSimpleGenericTypes and MCFullGenericTypes moved expressions to de.monticore.expressions and added expressions","title":"MontiCore 5.0.3"},{"location":"00.org/Explanations/CHANGELOG/#monticore-502","text":"Generated by the MontiCore version 5.0.1 Uses JavaDSL 4.3.13, Cd4Analysis 1.3.16, se-commons 1.7.9 Introduce deprecated annotation in grammars (#2215) Serialization of symobls Add reporter IncGenCheckReporter Configuration of the report path Specific resolving methods in generated scope classes Bugfixes","title":"MontiCore 5.0.2"},{"location":"00.org/Explanations/CHANGELOG/#monticore-501","text":"Generated by the MontiCore version 5.0.0 Uses JavaDSL 4.3.12, Cd4Analysis 1.3.13, se-commons 1.7.9 Bugfixes New methods defineHookPointWithDefault in GlobalExtensionManagement (MB) new method cmpToken in MCParser (MB) every (non-)terminal defined in an interface must be present in the implementing production (including Name and Usage Name) (CoCo) (BS) to ensure that any terminal (with a specific name) has to be implemented, use an empty string, e.g. interface Expression = operator=\"\"; new methods are generated for the referenced symbol and definition and the definition is saved in an attribute (generated wenn you write sth. like \"Name@Symbol\") (NP) coco that gives a warning if you do not extend conservative (NP) coco that attributes with the same usage Name have to reference the same symbol (NP) SpannedScope and Symbol Methods in ASTNode set to deprecated (NP)","title":"MontiCore 5.0.1"},{"location":"00.org/Explanations/CHANGELOG/#monticore-500","text":"Generated by the MontiCore version 4.5.5.1 Uses JavaDSL 4.3.11, Cd4Analysis 1.3.13, se-commons 1.7.8 Changed name building for list attributes in grammars (x:Name* -> getXList) Changed api for GlobalExtensionMangament and TemplateController (see reference manual) New api for AST nodes (constructor, getter and setter for lists and optional attributes, ...) Builder classes for AST nodes are external now. Signatures are similar to those in the corresponding AST node, except those methods which set or add something, these return the Builder itself (which allows method chaining) Changed default script to noemf for the generation of MontiCore. If you want to use emf you can generate monticore-grammar and Java-DSL with the profile \"emf\". This profile also creates the emf jars. You are also able to test the integration-tests with the profile \u201cemf-it-tests\u201d, which contains extra tests for the generation with emf. Parsed grammars are not stored as class diagram anymore. CD is only stored as report. Removed deprecated method filter(ResolvingInfo resolvingInfo, List symbols) use filter(ResolvingInfo, Collection) instead Removed deprecated method filter(ResolvingInfo resolvingInfo, String name, List symbols) use filter(ResolvingInfo, String, Map) instead Removed deprecated method create(Class symbolClass, SymbolKind symbolKind) use create(SymbolKind) instead Removed deprecated method getSymbols use getLocalSymbols instead Removed deprecated method resolve(SymbolPredicate predicate) use resolveMany(String, SymbolKind, Predicate) instead Removed deprecated method define use add instead Removed deprecated method resolve(ResolvingInfo resolvingInfo, String name, SymbolKind kind, AccessModifier modifier) Removed deprecated method checkIfContinueWithEnclosing use checkIfContinueWithEnclosingScope instead Removed deprecated method addResolver use addFilter(String, ResolvingFilter) instead Removed deprecated method addTopScopeResolver use addDefaultFilter instead Removed deprecated method addTopScopeResolvers use addDefaultFilters instead Removed deprecated method getTopScopeResolvingFilters use getDefaultFilters instead Removed deprecated constructer CommonResolvingFilter(Class symbolClass, SymbolKind targetKind) use CommonResolvingFilter(SymbolKind) instead Removed deprecated method continueWithScope and continueWithEnclosingScope Removed class FaildLoadingSymbol Removed deprecated method putInScopeAndLinkWithAst use addToScopeAndLinkWithNode instead Removed deprecated constructer CommonModelingLanguage(String, String, SymbolKind) use CommonModelingLanguage(String, String) instead Removed deprecated method addResolver use addResolvingFilter instead Removed deprecated method addResolver use addResolvingFilter instead Removed deprecated method getResolvers use getResolvingFilters instead Removed deprecated method loadAmbiguousModelAndCreateSymbolTable use loadModelsIntoScope instead Removed deprecated method loadAmbiguousModels use loadModels instead Removed deprecated method defineHookPoint(String) use glex.defineHookPoint instead Removed deprecated enum ParserExecution Removed deprecated method getParserTarget Removed deprecated method setParserTarget","title":"MontiCore 5.0.0"},{"location":"00.org/Explanations/CHANGELOG/#further-information","text":"see also MontiCore Reference Manual MontiCore project - MontiCore","title":"Further Information"},{"location":"00.org/Explanations/FAQ/","text":"FAQ for MontiCore Using Maven Eclipse shows me an error stating that my project configuration is not up-to-date. I get an error saying something about Lifecycle Mappings. Maven build fails because of a missing JDK path. Maven build for de.monticore.parent project fails in eclipse I have a very weird problem, seriously, very weird ... My .m2 folder does not exist. I get a strange error telling me that something is wrong with the UTF8 encoding. Changes I made on one module are not reflected in another module. Eclipse shows me an error stating that my project configuration is not up-to-date. Right-click that project and select Maven -> Update Project Configuration. I get an error saying something about Lifecycle Mappings. Install the m2e extensions mentioned in the developer tutorial. Maven build fails because of a missing JDK path. Change the installed runtime JREs to the installed JDK. Go to Window -> Preferences -> Installed JREs. Add the JDK path and select it to be the default one. Maven build for de.monticore.parent project fails in eclipse. Go to Window -> Preferences -> General -> Workspace. Disable \"Build automatically\" preference. I have a very weird problem, seriously, very weird ... Right-click that project and select Maven -> Update Project Configuration. My .m2 folder does not exist. Folders in Windows with a leading \".\" can only be created using the command line. Start the command line and type in \"mkdir .m2\" in your home folder. I get a strange error telling me that something is wrong with the UTF8 encoding. Change the UTF8 encoding by clicking on Window -> Preferences. Then, select the item as shown below and change the values accordingly. Changes I made on one module are not reflected in another module. Remember that all Maven modules are independent units. By default, they are not directly imported into each other. Instead, Maven resolves dependencies between projects by selecting packages (e.g.jar files) produced by these modules from your local Maven dependency repository. To make the latest version of a module available through this repository, you have to explicitly install it. If you execute an install on an aggregating POM-project, all child modules will be built with the current state of their depending projects as Maven always builds a hierarchy of modules in order of their mutual dependencies. However, if you are working in Eclipse, the workbench can import modules live. This feature is called \"Workspace resolution\" and is enabled by default for Eclipse automatic project builders. Nevertheless, if you build a module using a Run Configuration you have to explicitly activate \"Resolve Workspaces artifacts\". Further Information see also MontiCore Reference Manual MontiCore project - MontiCore","title":"FAQ"},{"location":"00.org/Explanations/FAQ/#faq-for-monticore","text":"","title":"FAQ for MontiCore"},{"location":"00.org/Explanations/FAQ/#using-maven","text":"Eclipse shows me an error stating that my project configuration is not up-to-date. I get an error saying something about Lifecycle Mappings. Maven build fails because of a missing JDK path. Maven build for de.monticore.parent project fails in eclipse I have a very weird problem, seriously, very weird ... My .m2 folder does not exist. I get a strange error telling me that something is wrong with the UTF8 encoding. Changes I made on one module are not reflected in another module. Eclipse shows me an error stating that my project configuration is not up-to-date. Right-click that project and select Maven -> Update Project Configuration. I get an error saying something about Lifecycle Mappings. Install the m2e extensions mentioned in the developer tutorial. Maven build fails because of a missing JDK path. Change the installed runtime JREs to the installed JDK. Go to Window -> Preferences -> Installed JREs. Add the JDK path and select it to be the default one. Maven build for de.monticore.parent project fails in eclipse. Go to Window -> Preferences -> General -> Workspace. Disable \"Build automatically\" preference. I have a very weird problem, seriously, very weird ... Right-click that project and select Maven -> Update Project Configuration. My .m2 folder does not exist. Folders in Windows with a leading \".\" can only be created using the command line. Start the command line and type in \"mkdir .m2\" in your home folder. I get a strange error telling me that something is wrong with the UTF8 encoding. Change the UTF8 encoding by clicking on Window -> Preferences. Then, select the item as shown below and change the values accordingly. Changes I made on one module are not reflected in another module. Remember that all Maven modules are independent units. By default, they are not directly imported into each other. Instead, Maven resolves dependencies between projects by selecting packages (e.g.jar files) produced by these modules from your local Maven dependency repository. To make the latest version of a module available through this repository, you have to explicitly install it. If you execute an install on an aggregating POM-project, all child modules will be built with the current state of their depending projects as Maven always builds a hierarchy of modules in order of their mutual dependencies. However, if you are working in Eclipse, the workbench can import modules live. This feature is called \"Workspace resolution\" and is enabled by default for Eclipse automatic project builders. Nevertheless, if you build a module using a Run Configuration you have to explicitly activate \"Resolve Workspaces artifacts\".","title":"Using Maven"},{"location":"00.org/Explanations/FAQ/#further-information","text":"see also MontiCore Reference Manual MontiCore project - MontiCore","title":"Further Information"},{"location":"00.org/Explanations/StatusOfGrammars/","text":"MontiCore Grammar Status Plans - an Overview MontiCore uses grammars as primary mechanism to describe DSLs and DSL components. The extended grammar format allows to compose language components by (1) inheriting, (2) extending, (3) embedding and (4) aggregating grammars (see the reference manual for details). From the grammars a lot of infrastructructure is generated, that is as well composable, can be extended with handwrittten code and most imprtandly, these extensions and the grammar composition are compatible, which leads to optimal forms of reuse . To improve understanding, what will happen with a grammar, we define the following set of stati and mention the status of each grammar, both in the explanation and in the grammar itself: Status of a Grammar MontiCore stable : Such a grammar is meant to be stable in the further development of MontiCore. The grammar is tested and assumed to be of high quality. It may rarely happen that smaller extensions are made in a conservative form, which means that (1) composition with any other grammars, (2) extensions and adaptations and (3) handwritten extensions will still work. Beta: In Stabilization : Such a grammar is in the process of becoming stable. One might already include the grammar, but some changes may still appear. (See task list for potential changes.) Alpha: Intention to become stable : Such a grammar is relatively fresh, but intended to become stable and useful. Changes may occur, e.g. when restructuring or bug fixing. Or it may be taken out of the process and become one of the following: Example : The grammar serves as working example, but will not have high priority on keeping the grammar up to date. One might use it as inspiration for their own developments. Deprecated : The grammar should not be used anymore, it is deprecated, will be deleted in the future, and a newer version of the content exists in another grammar. Unclarified : Some of the grammars are just there to be used for example as tests or as inspirations for your own definitions. It may be that such a grammar becomes stable, if enough interest exists. The deprecated grammars are often not listed in an overview anymore. There may also be further unclarfied and example grammars around. Marking the Status of Grammars A comment of the following form within the grammar defines this status: /* This is a MontiCore stable grammar. * Adaptations -- if any -- are conservative. */ /* Beta-version: This is intended to become a MontiCore stable grammar. */ /* Alpha-version: This is intended to become a MontiCore stable grammar. */ (but sometimes also omitted) Further Information see also MontiCore Reference Manual MontiCore project - MontiCore","title":"StatusOfGrammars"},{"location":"00.org/Explanations/StatusOfGrammars/#monticore-grammar-status-plans-an-overview","text":"MontiCore uses grammars as primary mechanism to describe DSLs and DSL components. The extended grammar format allows to compose language components by (1) inheriting, (2) extending, (3) embedding and (4) aggregating grammars (see the reference manual for details). From the grammars a lot of infrastructructure is generated, that is as well composable, can be extended with handwrittten code and most imprtandly, these extensions and the grammar composition are compatible, which leads to optimal forms of reuse . To improve understanding, what will happen with a grammar, we define the following set of stati and mention the status of each grammar, both in the explanation and in the grammar itself:","title":"MontiCore Grammar Status Plans - an Overview"},{"location":"00.org/Explanations/StatusOfGrammars/#status-of-a-grammar","text":"MontiCore stable : Such a grammar is meant to be stable in the further development of MontiCore. The grammar is tested and assumed to be of high quality. It may rarely happen that smaller extensions are made in a conservative form, which means that (1) composition with any other grammars, (2) extensions and adaptations and (3) handwritten extensions will still work. Beta: In Stabilization : Such a grammar is in the process of becoming stable. One might already include the grammar, but some changes may still appear. (See task list for potential changes.) Alpha: Intention to become stable : Such a grammar is relatively fresh, but intended to become stable and useful. Changes may occur, e.g. when restructuring or bug fixing. Or it may be taken out of the process and become one of the following: Example : The grammar serves as working example, but will not have high priority on keeping the grammar up to date. One might use it as inspiration for their own developments. Deprecated : The grammar should not be used anymore, it is deprecated, will be deleted in the future, and a newer version of the content exists in another grammar. Unclarified : Some of the grammars are just there to be used for example as tests or as inspirations for your own definitions. It may be that such a grammar becomes stable, if enough interest exists. The deprecated grammars are often not listed in an overview anymore. There may also be further unclarfied and example grammars around.","title":"Status of a Grammar"},{"location":"00.org/Explanations/StatusOfGrammars/#marking-the-status-of-grammars","text":"A comment of the following form within the grammar defines this status: /* This is a MontiCore stable grammar. * Adaptations -- if any -- are conservative. */ /* Beta-version: This is intended to become a MontiCore stable grammar. */ /* Alpha-version: This is intended to become a MontiCore stable grammar. */ (but sometimes also omitted)","title":"Marking the Status of Grammars"},{"location":"00.org/Explanations/StatusOfGrammars/#further-information","text":"see also MontiCore Reference Manual MontiCore project - MontiCore","title":"Further Information"},{"location":"00.org/Licenses/LICENSE-BSD3CLAUSE/","text":"Copyright (c) MontiCore*, All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. * belongs to RWTH and RIDT","title":"LICENSE BSD3CLAUSE"},{"location":"00.org/Licenses/LICENSE-LGPL/","text":"GNU LESSER GENERAL PUBLIC LICENSE Version 3, 29 June 2007 Copyright (C) 2007 Free Software Foundation, Inc. http://fsf.org/ Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. This version of the GNU Lesser General Public License incorporates the terms and conditions of version 3 of the GNU General Public License, supplemented by the additional permissions listed below. Additional Definitions. As used herein, \"this License\" refers to version 3 of the GNU Lesser General Public License, and the \"GNU GPL\" refers to version 3 of the GNU General Public License. \"The Library\" refers to a covered work governed by this License, other than an Application or a Combined Work as defined below. An \"Application\" is any work that makes use of an interface provided by the Library, but which is not otherwise based on the Library. Defining a subclass of a class defined by the Library is deemed a mode of using an interface provided by the Library. A \"Combined Work\" is a work produced by combining or linking an Application with the Library. The particular version of the Library with which the Combined Work was made is also called the \"Linked Version\". The \"Minimal Corresponding Source\" for a Combined Work means the Corresponding Source for the Combined Work, excluding any source code for portions of the Combined Work that, considered in isolation, are based on the Application, and not on the Linked Version. The \"Corresponding Application Code\" for a Combined Work means the object code and/or source code for the Application, including any data and utility programs needed for reproducing the Combined Work from the Application, but excluding the System Libraries of the Combined Work. Exception to Section 3 of the GNU GPL. You may convey a covered work under sections 3 and 4 of this License without being bound by section 3 of the GNU GPL. Conveying Modified Versions. If you modify a copy of the Library, and, in your modifications, a facility refers to a function or data to be supplied by an Application that uses the facility (other than as an argument passed when the facility is invoked), then you may convey a copy of the modified version: a) under this License, provided that you make a good faith effort to ensure that, in the event an Application does not supply the function or data, the facility still operates, and performs whatever part of its purpose remains meaningful, or b) under the GNU GPL, with none of the additional permissions of this License applicable to that copy. Object Code Incorporating Material from Library Header Files. The object code form of an Application may incorporate material from a header file that is part of the Library. You may convey such object code under terms of your choice, provided that, if the incorporated material is not limited to numerical parameters, data structure layouts and accessors, or small macros, inline functions and templates (ten or fewer lines in length), you do both of the following: a) Give prominent notice with each copy of the object code that the Library is used in it and that the Library and its use are covered by this License. b) Accompany the object code with a copy of the GNU GPL and this license document. Combined Works. You may convey a Combined Work under terms of your choice that, taken together, effectively do not restrict modification of the portions of the Library contained in the Combined Work and reverse engineering for debugging such modifications, if you also do each of the following: a) Give prominent notice with each copy of the Combined Work that the Library is used in it and that the Library and its use are covered by this License. b) Accompany the Combined Work with a copy of the GNU GPL and this license document. c) For a Combined Work that displays copyright notices during execution, include the copyright notice for the Library among these notices, as well as a reference directing the user to the copies of the GNU GPL and this license document. d) Do one of the following: 0. Convey the Minimal Corresponding Source under the terms of this License, and the Corresponding Application Code in a form suitable for, and under terms that permit, the user to recombine or relink the Application with a modified version of the Linked Version to produce a modified Combined Work, in the manner specified by section 6 of the GNU GPL for conveying Corresponding Source. 1. Use a suitable shared library mechanism for linking with the Library. A suitable mechanism is one that (a) uses at run time a copy of the Library already present on the user's computer system, and (b) will operate properly with a modified version of the Library that is interface-compatible with the Linked Version. e) Provide Installation Information, but only if you would otherwise be required to provide such information under section 6 of the GNU GPL, and only to the extent that such information is necessary to install and execute a modified version of the Combined Work produced by recombining or relinking the Application with a modified version of the Linked Version. (If you use option 5d0, the Installation Information must accompany the Minimal Corresponding Source and Corresponding Application Code. If you use option 5d1, you must provide the Installation Information in the manner specified by section 6 of the GNU GPL for conveying Corresponding Source.) Combined Libraries. You may place library facilities that are a work based on the Library side by side in a single library together with other library facilities that are not Applications and are not covered by this License, and convey such a combined library under terms of your choice, if you do both of the following: a) Accompany the combined library with a copy of the same work based on the Library, uncombined with any other library facilities, conveyed under the terms of this License. b) Give prominent notice with the combined library that part of it is a work based on the Library, and explaining where to find the accompanying uncombined form of the same work. Revised Versions of the GNU Lesser General Public License. The Free Software Foundation may publish revised and/or new versions of the GNU Lesser General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Library as you received it specifies that a certain numbered version of the GNU Lesser General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that published version or of any later version published by the Free Software Foundation. If the Library as you received it does not specify a version number of the GNU Lesser General Public License, you may choose any version of the GNU Lesser General Public License ever published by the Free Software Foundation. If the Library as you received it specifies that a proxy can decide whether future versions of the GNU Lesser General Public License shall apply, that proxy's public statement of acceptance of any version is permanent authorization for you to choose that version for the Library.","title":"LICENSE LGPL"},{"location":"00.org/Licenses/LICENSE-LGPL/#gnu-lesser-general-public-license","text":"Version 3, 29 June 2007 Copyright (C) 2007 Free Software Foundation, Inc. http://fsf.org/ Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. This version of the GNU Lesser General Public License incorporates the terms and conditions of version 3 of the GNU General Public License, supplemented by the additional permissions listed below. Additional Definitions. As used herein, \"this License\" refers to version 3 of the GNU Lesser General Public License, and the \"GNU GPL\" refers to version 3 of the GNU General Public License. \"The Library\" refers to a covered work governed by this License, other than an Application or a Combined Work as defined below. An \"Application\" is any work that makes use of an interface provided by the Library, but which is not otherwise based on the Library. Defining a subclass of a class defined by the Library is deemed a mode of using an interface provided by the Library. A \"Combined Work\" is a work produced by combining or linking an Application with the Library. The particular version of the Library with which the Combined Work was made is also called the \"Linked Version\". The \"Minimal Corresponding Source\" for a Combined Work means the Corresponding Source for the Combined Work, excluding any source code for portions of the Combined Work that, considered in isolation, are based on the Application, and not on the Linked Version. The \"Corresponding Application Code\" for a Combined Work means the object code and/or source code for the Application, including any data and utility programs needed for reproducing the Combined Work from the Application, but excluding the System Libraries of the Combined Work. Exception to Section 3 of the GNU GPL. You may convey a covered work under sections 3 and 4 of this License without being bound by section 3 of the GNU GPL. Conveying Modified Versions. If you modify a copy of the Library, and, in your modifications, a facility refers to a function or data to be supplied by an Application that uses the facility (other than as an argument passed when the facility is invoked), then you may convey a copy of the modified version: a) under this License, provided that you make a good faith effort to ensure that, in the event an Application does not supply the function or data, the facility still operates, and performs whatever part of its purpose remains meaningful, or b) under the GNU GPL, with none of the additional permissions of this License applicable to that copy. Object Code Incorporating Material from Library Header Files. The object code form of an Application may incorporate material from a header file that is part of the Library. You may convey such object code under terms of your choice, provided that, if the incorporated material is not limited to numerical parameters, data structure layouts and accessors, or small macros, inline functions and templates (ten or fewer lines in length), you do both of the following: a) Give prominent notice with each copy of the object code that the Library is used in it and that the Library and its use are covered by this License. b) Accompany the object code with a copy of the GNU GPL and this license document. Combined Works. You may convey a Combined Work under terms of your choice that, taken together, effectively do not restrict modification of the portions of the Library contained in the Combined Work and reverse engineering for debugging such modifications, if you also do each of the following: a) Give prominent notice with each copy of the Combined Work that the Library is used in it and that the Library and its use are covered by this License. b) Accompany the Combined Work with a copy of the GNU GPL and this license document. c) For a Combined Work that displays copyright notices during execution, include the copyright notice for the Library among these notices, as well as a reference directing the user to the copies of the GNU GPL and this license document. d) Do one of the following: 0. Convey the Minimal Corresponding Source under the terms of this License, and the Corresponding Application Code in a form suitable for, and under terms that permit, the user to recombine or relink the Application with a modified version of the Linked Version to produce a modified Combined Work, in the manner specified by section 6 of the GNU GPL for conveying Corresponding Source. 1. Use a suitable shared library mechanism for linking with the Library. A suitable mechanism is one that (a) uses at run time a copy of the Library already present on the user's computer system, and (b) will operate properly with a modified version of the Library that is interface-compatible with the Linked Version. e) Provide Installation Information, but only if you would otherwise be required to provide such information under section 6 of the GNU GPL, and only to the extent that such information is necessary to install and execute a modified version of the Combined Work produced by recombining or relinking the Application with a modified version of the Linked Version. (If you use option 5d0, the Installation Information must accompany the Minimal Corresponding Source and Corresponding Application Code. If you use option 5d1, you must provide the Installation Information in the manner specified by section 6 of the GNU GPL for conveying Corresponding Source.) Combined Libraries. You may place library facilities that are a work based on the Library side by side in a single library together with other library facilities that are not Applications and are not covered by this License, and convey such a combined library under terms of your choice, if you do both of the following: a) Accompany the combined library with a copy of the same work based on the Library, uncombined with any other library facilities, conveyed under the terms of this License. b) Give prominent notice with the combined library that part of it is a work based on the Library, and explaining where to find the accompanying uncombined form of the same work. Revised Versions of the GNU Lesser General Public License. The Free Software Foundation may publish revised and/or new versions of the GNU Lesser General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Library as you received it specifies that a certain numbered version of the GNU Lesser General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that published version or of any later version published by the Free Software Foundation. If the Library as you received it does not specify a version number of the GNU Lesser General Public License, you may choose any version of the GNU Lesser General Public License ever published by the Free Software Foundation. If the Library as you received it specifies that a proxy can decide whether future versions of the GNU Lesser General Public License shall apply, that proxy's public statement of acceptance of any version is permanent authorization for you to choose that version for the Library.","title":"GNU LESSER GENERAL PUBLIC LICENSE"},{"location":"00.org/Licenses/LICENSE-MONTICORE-3-LEVEL/","text":"MontiCore 3-Level License model MontiCore is a language workbench for an efficient development of domain-specific languages (DSLs). To prevent too many different public versions of the library itself, it is partly published under LGPL. To be usable in commercial and any other forms of projects, the finally generated code is, however, completely freely available. Three levels of licenses are needed. License overview The MontiCore Languag Workbench deals with three levels of code: (Level 3) MontiCore: the main libary constituting the LWB, (Level 2) tool derivates, that are to a large extent generated by the MontiCore LWB, and (Level 1) product code that is finally generated by tool derivates. This also includes analytical results, thus as results of consistency checks, code smells, test infrastructures, etc. Each level has its own and different license: (Level 3) MontiCore: the main LWB components are published under the LGPL license (see LGPL V3.0 ). (Level 2) Tool derivate: when a tool is derived using the MontiCore language workbench, then the result falls under the BSD 3 Clause license (see BSD-3-Clause ). (Level 1) Product code: when a MontiCore tool derivate is used to generate code, the generated code is absolutely free for each form of use including commercial use without any license and thus without any restriction from MontiCore itself. As a consequence using MontiCore during development is rather flexible and the final products do not have any restriction. Please not that the developers of tools may impose their own form of restrictions i.e. licenses on their tools respectively the results generated by these tools. MontiCore 3-level License on Files This repository for the MontiCore language workbench contains three kinds of artifacts: Java-files that are executed in the MontiCore LWB. They are under LGPL licence. Java-files that belong to the runtime environment (RTE) and are thus copied to the generated code. They are under BSD 3 Clause license. Templates executed during generation. They are also under BSD 3 Clause license, because parts of them are copied to the generated code. As a result, a tool derivate (level 2) does not contain any LGPL code, but only BSD 3 Clause code. Executing the tool derivate then produces completely free code (level 1). If questions appear e.g. on using MontiCore itself in a product or building an interpreter, please contact monticore@se-rwth.de. Underlying Licenses The MontiCore 3 Level license is built on: LGPL V3.0 BSD-3-Clause Further Information see also MontiCore Reference Manual MontiCore project - MontiCore","title":"License"},{"location":"00.org/Licenses/LICENSE-MONTICORE-3-LEVEL/#monticore-3-level-license-model","text":"MontiCore is a language workbench for an efficient development of domain-specific languages (DSLs). To prevent too many different public versions of the library itself, it is partly published under LGPL. To be usable in commercial and any other forms of projects, the finally generated code is, however, completely freely available. Three levels of licenses are needed.","title":"MontiCore 3-Level License model"},{"location":"00.org/Licenses/LICENSE-MONTICORE-3-LEVEL/#license-overview","text":"The MontiCore Languag Workbench deals with three levels of code: (Level 3) MontiCore: the main libary constituting the LWB, (Level 2) tool derivates, that are to a large extent generated by the MontiCore LWB, and (Level 1) product code that is finally generated by tool derivates. This also includes analytical results, thus as results of consistency checks, code smells, test infrastructures, etc. Each level has its own and different license: (Level 3) MontiCore: the main LWB components are published under the LGPL license (see LGPL V3.0 ). (Level 2) Tool derivate: when a tool is derived using the MontiCore language workbench, then the result falls under the BSD 3 Clause license (see BSD-3-Clause ). (Level 1) Product code: when a MontiCore tool derivate is used to generate code, the generated code is absolutely free for each form of use including commercial use without any license and thus without any restriction from MontiCore itself. As a consequence using MontiCore during development is rather flexible and the final products do not have any restriction. Please not that the developers of tools may impose their own form of restrictions i.e. licenses on their tools respectively the results generated by these tools.","title":"License overview"},{"location":"00.org/Licenses/LICENSE-MONTICORE-3-LEVEL/#monticore-3-level-license-on-files","text":"This repository for the MontiCore language workbench contains three kinds of artifacts: Java-files that are executed in the MontiCore LWB. They are under LGPL licence. Java-files that belong to the runtime environment (RTE) and are thus copied to the generated code. They are under BSD 3 Clause license. Templates executed during generation. They are also under BSD 3 Clause license, because parts of them are copied to the generated code. As a result, a tool derivate (level 2) does not contain any LGPL code, but only BSD 3 Clause code. Executing the tool derivate then produces completely free code (level 1). If questions appear e.g. on using MontiCore itself in a product or building an interpreter, please contact monticore@se-rwth.de.","title":"MontiCore 3-level License on Files"},{"location":"00.org/Licenses/LICENSE-MONTICORE-3-LEVEL/#underlying-licenses","text":"The MontiCore 3 Level license is built on: LGPL V3.0 BSD-3-Clause","title":"Underlying Licenses"},{"location":"00.org/Licenses/LICENSE-MONTICORE-3-LEVEL/#further-information","text":"see also MontiCore Reference Manual MontiCore project - MontiCore","title":"Further Information"},{"location":"docs/BestPractices-Errors/","text":"MontiCore Best Practices - Understanding Errors, Defining Errors [[ TOC ]] Errors happen. Some happen because of faults in the code (we call that internal errors), some happen because we haven't well explained how to use MontiCore and how to use the generated code. Here we try to add infromation how to handle occuring errors. We use the eror code for an easier identification. Error code start with 0x and use 5(!) hex characters and thus should be at the same time memorizable (because not completely unknown, but still not so common that they could be taken for something else). Handling Errors 0x..... How to use Expressions (0xA0129) Expression is a predefined nonterminal in the MontiCore basic grammars. Because of the infix notation of some operators and similar challenges, it is usually not possible to use a subset of the expressions only. For example use of ConditionalExpression may lead to a parser generation error (i.e. 0xA0129 ). Solutions: Use nonterminal Expression and forbid all unwanted alternatives through context conditions. Think of allowing more general expressions? If especially the syntax of if . then . else . shall be reused, why not defining this in a new nonterminal and ignoring that the same syntactic constructs were already available in another production. Defined by: CKi, BR. Further Information Overview Best Practices MontiCore project - MontiCore see also MontiCore Reference Manual","title":"BestPractices Errors"},{"location":"docs/BestPractices-Errors/#monticore-best-practices-understanding-errors-defining-errors","text":"[[ TOC ]] Errors happen. Some happen because of faults in the code (we call that internal errors), some happen because we haven't well explained how to use MontiCore and how to use the generated code. Here we try to add infromation how to handle occuring errors. We use the eror code for an easier identification. Error code start with 0x and use 5(!) hex characters and thus should be at the same time memorizable (because not completely unknown, but still not so common that they could be taken for something else).","title":"MontiCore Best Practices - Understanding Errors, Defining Errors"},{"location":"docs/BestPractices-Errors/#handling-errors-0x","text":"","title":"Handling Errors 0x....."},{"location":"docs/BestPractices-Errors/#how-to-use-expressions-0xa0129","text":"Expression is a predefined nonterminal in the MontiCore basic grammars. Because of the infix notation of some operators and similar challenges, it is usually not possible to use a subset of the expressions only. For example use of ConditionalExpression may lead to a parser generation error (i.e. 0xA0129 ). Solutions: Use nonterminal Expression and forbid all unwanted alternatives through context conditions. Think of allowing more general expressions? If especially the syntax of if . then . else . shall be reused, why not defining this in a new nonterminal and ignoring that the same syntactic constructs were already available in another production. Defined by: CKi, BR.","title":"How to use Expressions (0xA0129)"},{"location":"docs/BestPractices-Errors/#further-information","text":"Overview Best Practices MontiCore project - MontiCore see also MontiCore Reference Manual","title":"Further Information"},{"location":"docs/BestPractices-Language-Design/","text":"MontiCore Best Practices - Designing Languages [[ TOC ]] MontiCore provides a number of options to design languages, access and modify the abstract syntax tree, and produce output files. Some general questions on how to design a complete languages are adressed here. Designing A Language Correct language vs. superset? When you know that the incoming model will be correct, because they are generated by algorithm, you can decide to pass a (slight) superset This may simplify the development process for two reasons: (a) you may derive a simpler grammar and (b) you may omit definition of context conditions. But beware: (a) situations may change and manually changed models might come in or (b) the is adapted by an ill-behaving pre-processor or (c) the model may come in a wrong version. This applies mainly for unreadable languages, such as JSON or XML. Defined by: BR Versioning an evolving langauge? When languages evolve, models may become invalid, because certain (now obligatory) parts are missing, or old keywords are used. We generally believe that a language that is made for long lasting models should not embody its version in the models (i.e. like Java, C++ and other GPLs and unlike XML dialects). When evolving a language, you should only evolve it in conservative form, i.e. All new elements are optional by .? , .* or offer new alternatives (old | new) Old elements or keywords are not simply removed, but forbidden by coco warnings, marking them as deprecated for a while. Downward compatibility of newer models, however, is not useful. We can savely enforce developers should normally use the newest versions of their tools. Defined by: BR Language Design in the Large Making Transitively Inherited Grammars Explicit? When the grammar inclusion hierachy becomes larger, there will be redundancy. In: grammar A { .. } ; grammar B extends A { .. } ; grammar C extends A,B { .. } ; grammar D extends B { .. } ; Grammars C and D actually include the same nonterminals. If A is made explicit, you have more information right at hand, but also larger grammars. It is a matter of taste. A recommendation: when you use nonterminals from A explicitly, then also make the extension explicit. However, be consistent. How to Achieve Modularity (in the Sense of Decoupling) Modularity in general is an important design principle. In the case of model-based code generation, modularity involves the following dimensions: Modelling languages Models Generator Generated code Runtime-Environment (RTE) including imported standard libraries Software architecture (of the overal system), software stack These dimensions are not orthogonal, but also not completely interelated. The actual organisation will depend on the form of project. A weak form of modularity would be to organize things in well understood substructures such as packages. A deeper form of modularity deals with possibility for individual reuse and thus an explicit decoupling of individual components. We aim for decoupling (even if developed in the same git project). Modularity also deals with extensibility and adaptation . A principle for adaptation for the generator , the generated code , and the RTE is to design each of them like a framework with explicit extension points. Extension points may be (empty) hook methods to be filled, Java interfaces to be implemented and their objects injected to the code e.g. via factories, builders od simply method parameters. A principle for modularity for the the generator , the generated code , and the RTE is to design parts of them as independent library functions (or larger: components) that can be used if needed. We recommend to modularize whenever complexity overwhelms or extensibility and adaptability are important: MontiCore has powerful techniques for adaptation, extension and composition of modelling languages (through their grammars). See the reference manual . MontiCore has powerful techniques for the aggregation of models -- using the same principles as programming languages, namely allowing to keep the models independent (and thus storable, versionable, reusable) artifacts, while they are semantically and through the generator technology well integrated. The appropriate approach is based on using foreign models, e.g. through import statements and sharing symbol infrastructures as described in the reference manual . The generator provides (a) many Java classes and methods that can be overridden (b) Freemarker templates hook points to extend and replace templates, and (c) can be customized using a groovy script. The generator iteself is often structured along the software architecture / stack, e.g. in frontend, application backend, data base, transport layer, etc. The generated code must be designed appropriately by the generator designer, by generating builders, mills, etc. for each form of product - quite similar to MontiCore itself. The generated code is usually structured along the components or sub-systems that the software architecture defines. The RTE is probably well designed if it is usable a normal framework. Please note: it is not easy to design modularity and extensibility from beginning. Framework design has shown that this is an iterative optimizing process. It must be avoided to design too many extension elements into the system from the beginning, because this adds a lot of complexity. Defined by: BR Realizing Embedding through an Interface Nonterminal Extension Point Consider the following scenario: A language Host defines an extension point through an interface nonterminal. grammar Host { A = I*; interface I; } Another language Embedded that has no connection to the Host language, defines a class nonterminal E . grammar Embedded { E = \"something\"; } MontiCore provides alternative solutions to embed the language Embedded into the language Host at the extension point I . All solutions presented here require to implement a new grammar G that extends the grammars Embedded and Host , which reuses the start nonterminal of the Host grammar: grammar G extends Host, Embedded { start A; } The connection between extension point and extension is performed by an additional grammar rule in the grammar G . This can be realized in one of the following ways, each of which has its own advantages and disadvantages: Embedding through overriding of extension rule and implementing extension point rule: E implements I; Advantage: simple embedding rule Disadvantage: does not work in combination with inheritance of extension rule Should therefore only be used, it E is not used anywhere else (= in not other language that is potentially used in combination with this language) Embedding through extending extension rule and implementing extension point rule: IE extends E implements I = \"something\"; Advantage: does work in combination with inheritance of extension rule Disadvantage: cloning of RHS of the extension rule can produce inconsistencies if E is changed Can be used if it is assured that this rule is adjusted whenever E is changed, e.g., by assuming that E is not modified at all Embedding through implementing extension point rule and providing extension on right-hand side: IE implements I = E; Advantage: does work in combination with inheritance of extension rule Disadvantage: introduces new level of indirection in AST that invalidates check whether required abstract syntax (RHS of interface nonterminal) is present Should therefore not be used, if the interface has a right-hand side Defined by: AB Further Information Overview Best Practices MontiCore project - MontiCore see also MontiCore Reference Manual","title":"BestPractices Language Design"},{"location":"docs/BestPractices-Language-Design/#monticore-best-practices-designing-languages","text":"[[ TOC ]] MontiCore provides a number of options to design languages, access and modify the abstract syntax tree, and produce output files. Some general questions on how to design a complete languages are adressed here.","title":"MontiCore Best Practices - Designing Languages"},{"location":"docs/BestPractices-Language-Design/#designing-a-language","text":"","title":"Designing A Language"},{"location":"docs/BestPractices-Language-Design/#correct-language-vs-superset","text":"When you know that the incoming model will be correct, because they are generated by algorithm, you can decide to pass a (slight) superset This may simplify the development process for two reasons: (a) you may derive a simpler grammar and (b) you may omit definition of context conditions. But beware: (a) situations may change and manually changed models might come in or (b) the is adapted by an ill-behaving pre-processor or (c) the model may come in a wrong version. This applies mainly for unreadable languages, such as JSON or XML. Defined by: BR","title":"Correct language vs. superset?"},{"location":"docs/BestPractices-Language-Design/#versioning-an-evolving-langauge","text":"When languages evolve, models may become invalid, because certain (now obligatory) parts are missing, or old keywords are used. We generally believe that a language that is made for long lasting models should not embody its version in the models (i.e. like Java, C++ and other GPLs and unlike XML dialects). When evolving a language, you should only evolve it in conservative form, i.e. All new elements are optional by .? , .* or offer new alternatives (old | new) Old elements or keywords are not simply removed, but forbidden by coco warnings, marking them as deprecated for a while. Downward compatibility of newer models, however, is not useful. We can savely enforce developers should normally use the newest versions of their tools. Defined by: BR","title":"Versioning an evolving langauge?"},{"location":"docs/BestPractices-Language-Design/#language-design-in-the-large","text":"","title":"Language Design in the Large"},{"location":"docs/BestPractices-Language-Design/#making-transitively-inherited-grammars-explicit","text":"When the grammar inclusion hierachy becomes larger, there will be redundancy. In: grammar A { .. } ; grammar B extends A { .. } ; grammar C extends A,B { .. } ; grammar D extends B { .. } ; Grammars C and D actually include the same nonterminals. If A is made explicit, you have more information right at hand, but also larger grammars. It is a matter of taste. A recommendation: when you use nonterminals from A explicitly, then also make the extension explicit. However, be consistent.","title":"Making Transitively Inherited Grammars Explicit?"},{"location":"docs/BestPractices-Language-Design/#how-to-achieve-modularity-in-the-sense-of-decoupling","text":"Modularity in general is an important design principle. In the case of model-based code generation, modularity involves the following dimensions: Modelling languages Models Generator Generated code Runtime-Environment (RTE) including imported standard libraries Software architecture (of the overal system), software stack These dimensions are not orthogonal, but also not completely interelated. The actual organisation will depend on the form of project. A weak form of modularity would be to organize things in well understood substructures such as packages. A deeper form of modularity deals with possibility for individual reuse and thus an explicit decoupling of individual components. We aim for decoupling (even if developed in the same git project). Modularity also deals with extensibility and adaptation . A principle for adaptation for the generator , the generated code , and the RTE is to design each of them like a framework with explicit extension points. Extension points may be (empty) hook methods to be filled, Java interfaces to be implemented and their objects injected to the code e.g. via factories, builders od simply method parameters. A principle for modularity for the the generator , the generated code , and the RTE is to design parts of them as independent library functions (or larger: components) that can be used if needed. We recommend to modularize whenever complexity overwhelms or extensibility and adaptability are important: MontiCore has powerful techniques for adaptation, extension and composition of modelling languages (through their grammars). See the reference manual . MontiCore has powerful techniques for the aggregation of models -- using the same principles as programming languages, namely allowing to keep the models independent (and thus storable, versionable, reusable) artifacts, while they are semantically and through the generator technology well integrated. The appropriate approach is based on using foreign models, e.g. through import statements and sharing symbol infrastructures as described in the reference manual . The generator provides (a) many Java classes and methods that can be overridden (b) Freemarker templates hook points to extend and replace templates, and (c) can be customized using a groovy script. The generator iteself is often structured along the software architecture / stack, e.g. in frontend, application backend, data base, transport layer, etc. The generated code must be designed appropriately by the generator designer, by generating builders, mills, etc. for each form of product - quite similar to MontiCore itself. The generated code is usually structured along the components or sub-systems that the software architecture defines. The RTE is probably well designed if it is usable a normal framework. Please note: it is not easy to design modularity and extensibility from beginning. Framework design has shown that this is an iterative optimizing process. It must be avoided to design too many extension elements into the system from the beginning, because this adds a lot of complexity. Defined by: BR","title":"How to Achieve Modularity (in the Sense of Decoupling)"},{"location":"docs/BestPractices-Language-Design/#realizing-embedding-through-an-interface-nonterminal-extension-point","text":"Consider the following scenario: A language Host defines an extension point through an interface nonterminal. grammar Host { A = I*; interface I; } Another language Embedded that has no connection to the Host language, defines a class nonterminal E . grammar Embedded { E = \"something\"; } MontiCore provides alternative solutions to embed the language Embedded into the language Host at the extension point I . All solutions presented here require to implement a new grammar G that extends the grammars Embedded and Host , which reuses the start nonterminal of the Host grammar: grammar G extends Host, Embedded { start A; } The connection between extension point and extension is performed by an additional grammar rule in the grammar G . This can be realized in one of the following ways, each of which has its own advantages and disadvantages: Embedding through overriding of extension rule and implementing extension point rule: E implements I; Advantage: simple embedding rule Disadvantage: does not work in combination with inheritance of extension rule Should therefore only be used, it E is not used anywhere else (= in not other language that is potentially used in combination with this language) Embedding through extending extension rule and implementing extension point rule: IE extends E implements I = \"something\"; Advantage: does work in combination with inheritance of extension rule Disadvantage: cloning of RHS of the extension rule can produce inconsistencies if E is changed Can be used if it is assured that this rule is adjusted whenever E is changed, e.g., by assuming that E is not modified at all Embedding through implementing extension point rule and providing extension on right-hand side: IE implements I = E; Advantage: does work in combination with inheritance of extension rule Disadvantage: introduces new level of indirection in AST that invalidates check whether required abstract syntax (RHS of interface nonterminal) is present Should therefore not be used, if the interface has a right-hand side Defined by: AB","title":"Realizing Embedding through an Interface Nonterminal Extension Point"},{"location":"docs/BestPractices-Language-Design/#further-information","text":"Overview Best Practices MontiCore project - MontiCore see also MontiCore Reference Manual","title":"Further Information"},{"location":"docs/BestPractices-Symbols-Scopes/","text":"MontiCore Best Practices - Symbols, Scopes, Symboltables [[ TOC ]] MontiCore provides a number of options to design languages, access and modify the abstract syntax tree, and produce output files. The never MontiCore release gives powerful capabilities to define and use symbols. But symbols, scopes, and symboltables are somewhat complex to design, but powerful in their use. Designing Symbols, Scopes and SymbolTables How to define a Symbol Usage without a given Symbol Definition grammar E { A = Name@S; symbol S = Name; } If you want to use a sepcial form of symbol that shall neither be defined inside the grammar of a language, nor shall it be imported. We can define symbols of kind S in the grammar in a grammar rule that is never reached by the parser from the start production. Through this, MontiCores generates: symbol table infrastructure for handling S symbols symbol table infrastructure for resolving these in E scopes, and integration of S symbols with the AST of A . However, S symbols not automatically instantiated. This has to be described manually, e.g., by extending the symbol table creator or via providing an adapter translating a foreign symbol into an S symbol. This can be used, e.g., in these scenarios: A name of a certain kind is introduced automatically the first time it is occurs in a model. If it occurs more than once, all other occurences of the name do not introduce new symbols. (e.g. this happens with features in FDs, and works because features do not have a body.) A name in a language E refers to a named element of another language, but the language shall be decoupled from E . Therefore, E introduces a symbol S and an adapter maps other symbols to S symbols. Defined by: AB, BR Further Information Overview Best Practices MontiCore project - MontiCore see also MontiCore Reference Manual","title":"BestPractices Symbols Scopes"},{"location":"docs/BestPractices-Symbols-Scopes/#monticore-best-practices-symbols-scopes-symboltables","text":"[[ TOC ]] MontiCore provides a number of options to design languages, access and modify the abstract syntax tree, and produce output files. The never MontiCore release gives powerful capabilities to define and use symbols. But symbols, scopes, and symboltables are somewhat complex to design, but powerful in their use.","title":"MontiCore Best Practices - Symbols, Scopes, Symboltables"},{"location":"docs/BestPractices-Symbols-Scopes/#designing-symbols-scopes-and-symboltables","text":"","title":"Designing Symbols, Scopes and SymbolTables"},{"location":"docs/BestPractices-Symbols-Scopes/#how-to-define-a-symbol-usage-without-a-given-symbol-definition","text":"grammar E { A = Name@S; symbol S = Name; } If you want to use a sepcial form of symbol that shall neither be defined inside the grammar of a language, nor shall it be imported. We can define symbols of kind S in the grammar in a grammar rule that is never reached by the parser from the start production. Through this, MontiCores generates: symbol table infrastructure for handling S symbols symbol table infrastructure for resolving these in E scopes, and integration of S symbols with the AST of A . However, S symbols not automatically instantiated. This has to be described manually, e.g., by extending the symbol table creator or via providing an adapter translating a foreign symbol into an S symbol. This can be used, e.g., in these scenarios: A name of a certain kind is introduced automatically the first time it is occurs in a model. If it occurs more than once, all other occurences of the name do not introduce new symbols. (e.g. this happens with features in FDs, and works because features do not have a body.) A name in a language E refers to a named element of another language, but the language shall be decoupled from E . Therefore, E introduces a symbol S and an adapter maps other symbols to S symbols. Defined by: AB, BR","title":"How to define a Symbol Usage without a given Symbol Definition"},{"location":"docs/BestPractices-Symbols-Scopes/#further-information","text":"Overview Best Practices MontiCore project - MontiCore see also MontiCore Reference Manual","title":"Further Information"},{"location":"docs/BestPractices-Syntax-Design/","text":"MontiCore Best Practices - Concrete and Abstract Syntax [[ TOC ]] MontiCore provides a number of options to design languages, access and modify the abstract syntax tree, and produce output files. This (currently unsorted and evolving) list of practices discusses solutions that we identified and applied as well as alternatives and their specfic advantages and drawbacks. The list also mentions where the solutions have been found and where they have been applied first. This file is partially temporary and also contains compact (incomplete) solutions. More detailed descriptions of best practices can be found in the MontiCore reference manual . Some of the best practices here will also be incorporated in the next version of the reference manual. Designing Concrete and Abstract Syntax Specific keywords that shall be used as normal names elsewhere A = \"foo\" B introduces foo as a keyword that cannot be used as an ordinary (variable) name anymore. To prevent that we may use: A = key(\"foo\") B instead, which introduces foo only at that specific point. In general, we use all Java keywords as permanent, but abstain from other permanent keywords, especially if they are only used for a specific purpose in a composable sublanguage, like in in the OCL. Defined by: BR Complex Token clashing with other uses of sub-tokens For example <- is supposed to be used as arrow, but in an expression 3<-10 is also syntactically allowed. The problem: as soon as \"<-\" is defined as token in any part of the current or any extended grammars, the expression 3<-10 would not be parsed as 3 < -10 anymore. Solutions: We might decompose the token to \"<\" \"-\" which in its consequence means that we put more burden to the contextfree parser and less to the regular scanner. (\"scannerless parsing\") Drawback: spaces would now be allowed inbetween. Decompose the token to {noSpace(2)}? \"<\" \"-\" . This (slightly hacking approach) prevents spaces between two tokens. The challenge: when designing a language component, we don't know yet what further uses will bring. This may include sub-tokens to come up with new interactions. This would require an (already defined) grammar with the complex token to be adapted afterwards (and thus conflict with the library idea). Remark: A forthcoming enhancement will provide an improved solution, keeping parsing efficiency and compositionality of grammars. Defined by: BR Extension forms in a component grammar A component grammar is meant for extension. MontiCore therefore provides five(!) mechanisms that can be used when a sub-grammar shall extend a super-grammar. The solutions are briefly discussed here: 1. Interface in the super-grammar * Introduce an interface and allow building of sub-nonterminals in sub-grammars. component grammar A { interface X; N = \"bla\" X \"blubb\"; } grammar B extends A { Y implements X = \"specific\" \"thing\" } * Advantage: Multiple extensions are possible at the same time. An NT Y can also implement multiple interfaces (like in Java). * Disadvantage: the designer of A explicitly has to design the hole (extension point) X and add it it into the production. 2. Overriding (empty) nonterminal from the super-grammar * Use a normal nonterminal X and override it in a sub-grammar. component grammar A { X = \"\"; N = \"bla\" X \"blubb\"; } grammar B extends A { @Override X = \"my\" \"thing\"; } * Advantage: Default implementation \"\" exists, no explicit filling needed. * Disadvantage: 1. The designer of A explicitly has to design the hole (extension point) X and inject it into other places. 2. Only one overriding alternative possible (i.e. multiple overriding in subgrammars are allowed, but only the most specific resides) . 3. Extending nonterminal from the super-grammar. * Use an empty normal nonterminal X and extend it in a sub-grammar. component grammar A { X = ; N = \"bla\" X \"blubb\"; } grammar B extends A { Y extends X = \"this\"; } * Advantage: Default implementation \"\" exists, no explicit filling needed. * Disadvantage: The designer of A explicitly has to design the hole (extension point) X and inject it into other places. * Care: Extension still allows the (empty) alternative X . 4. Using external nonterminals in the super-grammar. * Mark nonterminal X as external. component grammar A { external X; N = \"bla\" X \"blubb\"; } grammar B extends A { X = \"your\"; } * Advantage: Explctely marks a nonterminal as hole (extension point) in the grammar. Please observe that interface terminals may or not may be meant to be extended in sub-grammars. external is clearer here. * Disadvantage: 1. Leads to more objects in the AST. Both classes a.X and b.X are instantiated and a.X only links to b.X . 2. Only one filling of the hole is possible. Overriding the whole production. If you don't want to add a hole at any possible place of extension: component grammar A { N = \"bla\" \"blubb\"; } grammar B extends A { @Override N = \"bla\" \"my\" \"blubb\" \"now\"; } Advantage: Compact definition. No \" framework thinking \" needed (no need to forecast all potential extension points) Disadvantage: The entire production is overriden (some redundancy). Only one overriding alternative possible. Combinations are possible. Dependend on the anticipated forms of adaptatations option 1, 2, 3 and 5 are in use. Defined by: BR Avoid empty nonterminals (if body is known) From the two variants: A = \"bla\" B? C*; B = \"B's body\" ; C = \"C's body\" ; and A = \"bla\" B C; B = (\"B's body\")? ; C = (\"C's body\")* ; we generally prefer the first one, i.e. add multiplicities when using a nonterminal. This is a matter of taste, but useful to keep this consistent. Sometimes exceptions are useful. Defined by: SVa, BR Avoid complex tokens (1) The token definitions can only define regular expressions. Furthermore, the token parser (i.e. the lexer) does not consider backtracking. If combinations of characters may be split into several token sequences this leads to problems. E.g. in 3-2 and (-2) the - has different roles. Unfortunately these problems also occur when composing languages that make excessive use of (conflicting) token definitions. Solution: instead of defining a complex token like token NegativeNat = \"-\" Digits; we split the token and allow individual parsing into nonterminals: NegativeNat = negative:[\"-\"] Digits {noSpace()}? (where we assume Digits is a given token). As a workaround, we use the semantic predicate {noSpace()}? that ensures that between the two last processed token there is no space inbetween. If one of the token is optional we have to split the alternatives: SignedNatLiteral = (negative:[\"-\"]) Digits {noSpace()}? | Digits ; Adding a handcoded function like getValue() via astrule or the TOP-mechanism allows to use SignedNatLiteral like a token. Scannerless parsing is a principle where the tokens are reduced to simple characters (or character classes, such as [a-z] ). Scannerless parsing generally avoids this kinds of problems, but is way slower. This kind of solution tries to mediate between the two extremes benefitting from both approaches. Defined by: MB, in: MCCommonLiterals.mc4 and other literals grammars. Avoid complex tokens (2) Same general problem. In language composition conflicting token may lead to issues. For example Java allows 42. as a literal of type float. UML allows to define cardinalities like [42..44] . Composition clashes. Solution: In a Java sublanguage we split the token: SignedBasicFloatLiteral = ... | Digits \".\" {noSpace()}? ... ; This will ensure that [42..44] will be parsed like [ 42 .. 44 ] in a language composition as well. It generally seems that overly complex composed tokens may lead to issues especially if the language allows compact models. Suboptimal tokens may be e.g. \"[[\" (vs. nested lists), or \"<-\" (vs. 3 < -2 ). Defined by: MC team. How to define keyword enumerations A finite set of kewyword-based alternatives can be defined in several forms: Standard thre keywords act as alternative: N = ([\"public\"] | [\"protected\"] | [\"private\"]) ; Effects: not extensible without overriding and repetition introduces boolean flags, where only one can be true at a time Use an enumeration nonterminal enumeration E = \"public\" | \"protected\" | \"private\" ; N = E ; Effects: not extensible Use an interface and subclasses with almost empty body: interface E ; P1 implements E = \"public\" ; P2 implements E = \"protected\" ; P3 implements E = \"private\" ; N = E ; Effects: very extensible in various ways (even beyond mere keywords) visitor can easily adress the keywords (i.e. by visit(P1) ...) Disadvantage: Clumsy notation and visitors are always needed. Defined by: SVa, BR. Common AST-Access to Syntactically Similar Nonterminals Sometimes the following occurs (e.g. in associations of CDs or interactions of SD): A = X Y Z; B = Z Y X; The concrete syntax differs (in order), but the syntactic concepts are the same. To allow common access, a common interface nonterminal is introduced that is not used in the grammar directly. This doesn't change the concrete syntax but allows common AST access: interface F = X Y Z; // order is irrelevant A implements F = X Y Z; B implements F = Z Y X; Defined by: BR. How and when to use Names for Nonterminals Normally names like expr:Expr can be avoided, which makes a grammar easier to read and more concise, i.e. Expr alone has the same effect. There may be two reasons to use a name: Nonterminal X occurs several times and we want to distinguish: left:Expr \"*\" right:Expr We can also use the name to describe the purpose of the nonterminal, i.e. MyVariable implements Variable = Name \"=\" initial:Expression; vs: MyParameter implements Variable = Name \"=\" default:Expression; Defined by: BR. Further Information Overview Best Practices MontiCore project - MontiCore see also MontiCore Reference Manual","title":"BestPractices Syntax Design"},{"location":"docs/BestPractices-Syntax-Design/#monticore-best-practices-concrete-and-abstract-syntax","text":"[[ TOC ]] MontiCore provides a number of options to design languages, access and modify the abstract syntax tree, and produce output files. This (currently unsorted and evolving) list of practices discusses solutions that we identified and applied as well as alternatives and their specfic advantages and drawbacks. The list also mentions where the solutions have been found and where they have been applied first. This file is partially temporary and also contains compact (incomplete) solutions. More detailed descriptions of best practices can be found in the MontiCore reference manual . Some of the best practices here will also be incorporated in the next version of the reference manual.","title":"MontiCore Best Practices - Concrete and Abstract Syntax"},{"location":"docs/BestPractices-Syntax-Design/#designing-concrete-and-abstract-syntax","text":"","title":"Designing Concrete and Abstract Syntax"},{"location":"docs/BestPractices-Syntax-Design/#specific-keywords-that-shall-be-used-as-normal-names-elsewhere","text":"A = \"foo\" B introduces foo as a keyword that cannot be used as an ordinary (variable) name anymore. To prevent that we may use: A = key(\"foo\") B instead, which introduces foo only at that specific point. In general, we use all Java keywords as permanent, but abstain from other permanent keywords, especially if they are only used for a specific purpose in a composable sublanguage, like in in the OCL. Defined by: BR","title":"Specific keywords that shall be used as normal names elsewhere"},{"location":"docs/BestPractices-Syntax-Design/#complex-token-clashing-with-other-uses-of-sub-tokens","text":"For example <- is supposed to be used as arrow, but in an expression 3<-10 is also syntactically allowed. The problem: as soon as \"<-\" is defined as token in any part of the current or any extended grammars, the expression 3<-10 would not be parsed as 3 < -10 anymore. Solutions: We might decompose the token to \"<\" \"-\" which in its consequence means that we put more burden to the contextfree parser and less to the regular scanner. (\"scannerless parsing\") Drawback: spaces would now be allowed inbetween. Decompose the token to {noSpace(2)}? \"<\" \"-\" . This (slightly hacking approach) prevents spaces between two tokens. The challenge: when designing a language component, we don't know yet what further uses will bring. This may include sub-tokens to come up with new interactions. This would require an (already defined) grammar with the complex token to be adapted afterwards (and thus conflict with the library idea). Remark: A forthcoming enhancement will provide an improved solution, keeping parsing efficiency and compositionality of grammars. Defined by: BR","title":"Complex Token clashing with other uses of sub-tokens"},{"location":"docs/BestPractices-Syntax-Design/#extension-forms-in-a-component-grammar","text":"A component grammar is meant for extension. MontiCore therefore provides five(!) mechanisms that can be used when a sub-grammar shall extend a super-grammar. The solutions are briefly discussed here: 1. Interface in the super-grammar * Introduce an interface and allow building of sub-nonterminals in sub-grammars. component grammar A { interface X; N = \"bla\" X \"blubb\"; } grammar B extends A { Y implements X = \"specific\" \"thing\" } * Advantage: Multiple extensions are possible at the same time. An NT Y can also implement multiple interfaces (like in Java). * Disadvantage: the designer of A explicitly has to design the hole (extension point) X and add it it into the production. 2. Overriding (empty) nonterminal from the super-grammar * Use a normal nonterminal X and override it in a sub-grammar. component grammar A { X = \"\"; N = \"bla\" X \"blubb\"; } grammar B extends A { @Override X = \"my\" \"thing\"; } * Advantage: Default implementation \"\" exists, no explicit filling needed. * Disadvantage: 1. The designer of A explicitly has to design the hole (extension point) X and inject it into other places. 2. Only one overriding alternative possible (i.e. multiple overriding in subgrammars are allowed, but only the most specific resides) . 3. Extending nonterminal from the super-grammar. * Use an empty normal nonterminal X and extend it in a sub-grammar. component grammar A { X = ; N = \"bla\" X \"blubb\"; } grammar B extends A { Y extends X = \"this\"; } * Advantage: Default implementation \"\" exists, no explicit filling needed. * Disadvantage: The designer of A explicitly has to design the hole (extension point) X and inject it into other places. * Care: Extension still allows the (empty) alternative X . 4. Using external nonterminals in the super-grammar. * Mark nonterminal X as external. component grammar A { external X; N = \"bla\" X \"blubb\"; } grammar B extends A { X = \"your\"; } * Advantage: Explctely marks a nonterminal as hole (extension point) in the grammar. Please observe that interface terminals may or not may be meant to be extended in sub-grammars. external is clearer here. * Disadvantage: 1. Leads to more objects in the AST. Both classes a.X and b.X are instantiated and a.X only links to b.X . 2. Only one filling of the hole is possible. Overriding the whole production. If you don't want to add a hole at any possible place of extension: component grammar A { N = \"bla\" \"blubb\"; } grammar B extends A { @Override N = \"bla\" \"my\" \"blubb\" \"now\"; } Advantage: Compact definition. No \" framework thinking \" needed (no need to forecast all potential extension points) Disadvantage: The entire production is overriden (some redundancy). Only one overriding alternative possible. Combinations are possible. Dependend on the anticipated forms of adaptatations option 1, 2, 3 and 5 are in use. Defined by: BR","title":"Extension forms in a  component grammar"},{"location":"docs/BestPractices-Syntax-Design/#avoid-empty-nonterminals-if-body-is-known","text":"From the two variants: A = \"bla\" B? C*; B = \"B's body\" ; C = \"C's body\" ; and A = \"bla\" B C; B = (\"B's body\")? ; C = (\"C's body\")* ; we generally prefer the first one, i.e. add multiplicities when using a nonterminal. This is a matter of taste, but useful to keep this consistent. Sometimes exceptions are useful. Defined by: SVa, BR","title":"Avoid empty nonterminals (if body is known)"},{"location":"docs/BestPractices-Syntax-Design/#avoid-complex-tokens-1","text":"The token definitions can only define regular expressions. Furthermore, the token parser (i.e. the lexer) does not consider backtracking. If combinations of characters may be split into several token sequences this leads to problems. E.g. in 3-2 and (-2) the - has different roles. Unfortunately these problems also occur when composing languages that make excessive use of (conflicting) token definitions. Solution: instead of defining a complex token like token NegativeNat = \"-\" Digits; we split the token and allow individual parsing into nonterminals: NegativeNat = negative:[\"-\"] Digits {noSpace()}? (where we assume Digits is a given token). As a workaround, we use the semantic predicate {noSpace()}? that ensures that between the two last processed token there is no space inbetween. If one of the token is optional we have to split the alternatives: SignedNatLiteral = (negative:[\"-\"]) Digits {noSpace()}? | Digits ; Adding a handcoded function like getValue() via astrule or the TOP-mechanism allows to use SignedNatLiteral like a token. Scannerless parsing is a principle where the tokens are reduced to simple characters (or character classes, such as [a-z] ). Scannerless parsing generally avoids this kinds of problems, but is way slower. This kind of solution tries to mediate between the two extremes benefitting from both approaches. Defined by: MB, in: MCCommonLiterals.mc4 and other literals grammars.","title":"Avoid complex tokens (1)"},{"location":"docs/BestPractices-Syntax-Design/#avoid-complex-tokens-2","text":"Same general problem. In language composition conflicting token may lead to issues. For example Java allows 42. as a literal of type float. UML allows to define cardinalities like [42..44] . Composition clashes. Solution: In a Java sublanguage we split the token: SignedBasicFloatLiteral = ... | Digits \".\" {noSpace()}? ... ; This will ensure that [42..44] will be parsed like [ 42 .. 44 ] in a language composition as well. It generally seems that overly complex composed tokens may lead to issues especially if the language allows compact models. Suboptimal tokens may be e.g. \"[[\" (vs. nested lists), or \"<-\" (vs. 3 < -2 ). Defined by: MC team.","title":"Avoid complex tokens (2)"},{"location":"docs/BestPractices-Syntax-Design/#how-to-define-keyword-enumerations","text":"A finite set of kewyword-based alternatives can be defined in several forms: Standard thre keywords act as alternative: N = ([\"public\"] | [\"protected\"] | [\"private\"]) ; Effects: not extensible without overriding and repetition introduces boolean flags, where only one can be true at a time Use an enumeration nonterminal enumeration E = \"public\" | \"protected\" | \"private\" ; N = E ; Effects: not extensible Use an interface and subclasses with almost empty body: interface E ; P1 implements E = \"public\" ; P2 implements E = \"protected\" ; P3 implements E = \"private\" ; N = E ; Effects: very extensible in various ways (even beyond mere keywords) visitor can easily adress the keywords (i.e. by visit(P1) ...) Disadvantage: Clumsy notation and visitors are always needed. Defined by: SVa, BR.","title":"How to define keyword enumerations"},{"location":"docs/BestPractices-Syntax-Design/#common-ast-access-to-syntactically-similar-nonterminals","text":"Sometimes the following occurs (e.g. in associations of CDs or interactions of SD): A = X Y Z; B = Z Y X; The concrete syntax differs (in order), but the syntactic concepts are the same. To allow common access, a common interface nonterminal is introduced that is not used in the grammar directly. This doesn't change the concrete syntax but allows common AST access: interface F = X Y Z; // order is irrelevant A implements F = X Y Z; B implements F = Z Y X; Defined by: BR.","title":"Common AST-Access to Syntactically Similar Nonterminals"},{"location":"docs/BestPractices-Syntax-Design/#how-and-when-to-use-names-for-nonterminals","text":"Normally names like expr:Expr can be avoided, which makes a grammar easier to read and more concise, i.e. Expr alone has the same effect. There may be two reasons to use a name: Nonterminal X occurs several times and we want to distinguish: left:Expr \"*\" right:Expr We can also use the name to describe the purpose of the nonterminal, i.e. MyVariable implements Variable = Name \"=\" initial:Expression; vs: MyParameter implements Variable = Name \"=\" default:Expression; Defined by: BR.","title":"How and when to use Names for Nonterminals"},{"location":"docs/BestPractices-Syntax-Design/#further-information","text":"Overview Best Practices MontiCore project - MontiCore see also MontiCore Reference Manual","title":"Further Information"},{"location":"docs/BestPractices/","text":"MontiCore Best Practices - A Guide For Small Solutions MontiCore provides a number of options to design languages, access and modify the abstract syntax tree, and produce output files. This (currently unsorted and evolving) list of practices discusses solutions that we identified and applied as well as alternatives and their specfic advantages and drawbacks. The list also mentions where the solutions have been found and where they have been applied first. The list is subdivided into several MD files tackling various language design areas. The list is partially temporary and also contains compact (incomplete) solutions. More detailed descriptions of best practices can be found in the MontiCore reference manual . Some of the best practices here will also be incorporated in the next version of the reference manual. Designing A Language includes: Language Design in the Large Designing Concrete and Abstract Syntax Handling Errors 0x..... Designing Symbols, Scopes and SymbolTables Generating Code with Templates (no practice defined here yet) Further Information MontiCore project - MontiCore see also MontiCore Reference Manual","title":"BestPractices"},{"location":"docs/BestPractices/#monticore-best-practices-a-guide-for-small-solutions","text":"MontiCore provides a number of options to design languages, access and modify the abstract syntax tree, and produce output files. This (currently unsorted and evolving) list of practices discusses solutions that we identified and applied as well as alternatives and their specfic advantages and drawbacks. The list also mentions where the solutions have been found and where they have been applied first. The list is subdivided into several MD files tackling various language design areas. The list is partially temporary and also contains compact (incomplete) solutions. More detailed descriptions of best practices can be found in the MontiCore reference manual . Some of the best practices here will also be incorporated in the next version of the reference manual. Designing A Language includes: Language Design in the Large Designing Concrete and Abstract Syntax Handling Errors 0x..... Designing Symbols, Scopes and SymbolTables Generating Code with Templates (no practice defined here yet) Further Information MontiCore project - MontiCore see also MontiCore Reference Manual","title":"MontiCore Best Practices - A Guide For Small Solutions"},{"location":"docs/BuildMontiCore/","text":"MontiCore - Language Workbench And Development Tool Framework MontiCore Reference Manual . General disclaimer (Repeated from the the BSD 3 Clause license): This software is provided by the copyright holders and contributors \"as is\" and any expressed or implied warranties, including, but not limited to, the implied warranties of merchantability and fitness for a particular purpose are disclaimed. In no event shall the copyright holder or contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of substitute goods or services; loss of use, data, or profits; or business interruption) however caused and on any theory of liability, whether in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage. Included Software This product includes the following software: * AntLR * FreeMarker Contribution When you want to contribute: Please make sure that your complete workspace only uses UNIX line endings (LF) and all files are UTF-8 without BOM. On Windows you should configure git to not automatically replace LF with CRLF during checkout by executing the following configuration: git config --global core.autocrlf input Build MontiCore MontiCore is currently partially still built using maven, but partially already migrated to gradle. It is recommended to use the MontiCore internal gradle wrapper ( gradlew ). Please note that from the top level build script, not everything is built and all tests executed. It is a deliberate decision, to exclude some of the longer lasting tasks. build the productive code (including the unit tests, ~8 min) mvn install skipping the unit tests: mvn install -Dmaven.test.skip=true run integration tests (which are not included in the unit tests, ~30 min) Integration tests of the generator: maven (deprecated): mvn install -f monticore-generator/it/pom.xml or gradle: in monticore-generator/it/ call gradlew build EMF Integration tests of the generator: maven (deprecated): mvn install -f monticore-generator/it/pom.xml -P emf-it-tests or gradle: in monticore-generator/it/ call gradlew build -PbuildProfile=emf Experiments (from the Reference Manual) as integration tests: maven (deprecated): mvn install -f monticore-generator/it/experiments/pom.xml or gradle: in monticore-generator/it/experiments/ call gradlew build Grammar integration tests: in monticore-grammar/monticore-grammar-it call gradlew build TemplateClassGenerator integration tests maven (deprecated): mvn install -f /monticore-templateclassgenerator/it/monticore-templateclassgenerator-it/pom.xml or gradle: in /monticore-templateclassgenerator/it/monticore-templateclassgenerator-it call gradlew build clean: call mvn clean cleaning integration tests: using maven (deprecated): mvn clean (including the -f argument, see above) using gradle gradlew clean within the corresponding directory (see above) Further Information see also MontiCore Reference Manual FAQ - FAQ Changelog - Release Notes MontiCore project - MontiCore","title":"BuildMontiCore"},{"location":"docs/BuildMontiCore/#monticore-language-workbench-and-development-tool-framework","text":"MontiCore Reference Manual .","title":"MontiCore - Language Workbench And Development Tool Framework"},{"location":"docs/BuildMontiCore/#general-disclaimer","text":"(Repeated from the the BSD 3 Clause license): This software is provided by the copyright holders and contributors \"as is\" and any expressed or implied warranties, including, but not limited to, the implied warranties of merchantability and fitness for a particular purpose are disclaimed. In no event shall the copyright holder or contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of substitute goods or services; loss of use, data, or profits; or business interruption) however caused and on any theory of liability, whether in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage.","title":"General disclaimer"},{"location":"docs/BuildMontiCore/#included-software","text":"This product includes the following software: * AntLR * FreeMarker","title":"Included Software"},{"location":"docs/BuildMontiCore/#contribution","text":"When you want to contribute: Please make sure that your complete workspace only uses UNIX line endings (LF) and all files are UTF-8 without BOM. On Windows you should configure git to not automatically replace LF with CRLF during checkout by executing the following configuration: git config --global core.autocrlf input","title":"Contribution"},{"location":"docs/BuildMontiCore/#build-monticore","text":"MontiCore is currently partially still built using maven, but partially already migrated to gradle. It is recommended to use the MontiCore internal gradle wrapper ( gradlew ). Please note that from the top level build script, not everything is built and all tests executed. It is a deliberate decision, to exclude some of the longer lasting tasks. build the productive code (including the unit tests, ~8 min) mvn install skipping the unit tests: mvn install -Dmaven.test.skip=true run integration tests (which are not included in the unit tests, ~30 min) Integration tests of the generator: maven (deprecated): mvn install -f monticore-generator/it/pom.xml or gradle: in monticore-generator/it/ call gradlew build EMF Integration tests of the generator: maven (deprecated): mvn install -f monticore-generator/it/pom.xml -P emf-it-tests or gradle: in monticore-generator/it/ call gradlew build -PbuildProfile=emf Experiments (from the Reference Manual) as integration tests: maven (deprecated): mvn install -f monticore-generator/it/experiments/pom.xml or gradle: in monticore-generator/it/experiments/ call gradlew build Grammar integration tests: in monticore-grammar/monticore-grammar-it call gradlew build TemplateClassGenerator integration tests maven (deprecated): mvn install -f /monticore-templateclassgenerator/it/monticore-templateclassgenerator-it/pom.xml or gradle: in /monticore-templateclassgenerator/it/monticore-templateclassgenerator-it call gradlew build clean: call mvn clean cleaning integration tests: using maven (deprecated): mvn clean (including the -f argument, see above) using gradle gradlew clean within the corresponding directory (see above)","title":"Build MontiCore"},{"location":"docs/BuildMontiCore/#further-information","text":"see also MontiCore Reference Manual FAQ - FAQ Changelog - Release Notes MontiCore project - MontiCore","title":"Further Information"},{"location":"docs/DevelopedLanguages/","text":"Languages and Language Components that have been developed with MontiCore The MontiCore language workbench has been under development already for a while and of course has old been used by our group to develop many other languages. Not all of those languages are of publicly available and some of these languages are equipped with tools based on MontiCore 5-. Some of these languages are monolithic, others are composed of each other. The available languages can also be used for adaptation, extension, and composition Please also have a look at our literature references for further information on many of the languages. MontiArc ADL is an architectural definition language for component and connector models with enhanced connection facilities, hierarchical decomposition etc. and provides a simulator [HRR12,BHH+17,Wor16,Hab16] . MontiArcAutomaton ADL is an extension of the architectural definition language MontiArc using automata to describe behavior. Some applications e.g. are of robotics, production, or InternetOfThings. [BKRW17a,HKR+16,BRW16a,Wor16] . UML/P is a derivation from UML, especially suited for agile development. See language definition and usage method in [Rum17,Rum16,Sch12] . UML/P Class Diagrams for data structures UML/P Object Diagrams for exemplaric situations: usable for constructive development as well as testing OCL/P as Java-variant of the OCL with a nice logic, set-comprehension etc. UML/P Statecharts for behavior UML/P Sequence Diagrams for interaction Activity Diagrams for workflows and requirements (an extension to the books) Delta-MontiArc [HRRS12,HKR+11,HRRS11] is a DSL for expressing deltas on MontiArc component definitions, which allows to model software product lines in a bottom up way. MontiArcHV [HRR+11] allows specifying component variability fully integrated within the component hierarchy located at variation points in component definitions. Java as full language as well as source for Java expressions, statements, attribute or method definitions. FeatureDSL is a DSL for feature diagrams in software product line approaches DeltaCD is a DSL for expressing deltas on class diagrams, which allows to model software product lines in a bottom up way Aerospace Constraint Specification Language is a DSL used to specify critical situations in an airspace including airplanes, weather, flight conditions and much more. [ZPK+11] clArc DSL Family: [PR13] Cloud Architecture Description Language: used to model of architectures of cloud-based systems; based on MontiArc. Target Description Language: used to model the infrastructure architecture of cloud-based systems. Mapping Description Language: used to model deployments between software and infrastructure architectures. Architecture Scenario Description Language: used to model scenario-based test cases for software architectures. I/O-TestDSL for the definition of stream-based, input-output related black-box tests for architecture definition languages like MontiArc. LightRocks , a modeling language for robotic assembly processes. cdViews is a DSL used to model partial views on class diagrams RBAC for Role-Based Access Control in enterprise information systems. MontiWis [[RR13,Rei16]] is a family of DSLs for the model-based, generative development of web information systems among others based on class diagrams, activity diagrams and views. HQL : Hibernate Query Language that maps to hibernate based executions. SQL the well known DB query language; used for embedding e.g. into other languages. XML the basic infrastructure for all XML dialects CarOLO DSLs for autonomic driving. This among others contains a DSL for defining road scenarios with moving vehicles as well a obstacles suited for laser, lidar, radar and camera sensors. This languages are part of the Darpa Urban Challenge 2007. [BR12b,BR12,Ber10,BR09] . ProcEd a Web-based Editing Solution for Domain Specific Process-Engineering [BGR09] . MontiWeb a modular development approach for Web Information Systems (which was later succeded by MontiWIS) [DRRS09] . C++ and its sublanguages for expressions, statements and definitions (but no generic types, no defines) MontiCore itself uses a family of DSLs for the definition of DSLs, i.e., their grammars. [HR17] Further Languages and Information MontiCore Online Demonstrator . (TODO: needs to be released) MontiCore Reference Manual . The reference Manual describes how to use MontiCore as a out-of-the-box language workbench ), but also as grey box tooling framework . It thus also gives an overview over a number of core mechanisms of MontiCore. List of core grammars . MontiCore concentrates on reuse. It therefore offers a set of predefined language components , usually identified through an appropriate component grammar allowing to define your own language as a composition of reusable assets efficiently. reusable assets are among others: several sets of literals , expressions and types , which are relatively freely composable. List of languages . This is a list of newer MontiCore 6 languages that can be used out of the box. Some of them are in development, others rather stable. These complete languages are usually composed of a number of language components. see also our literature list see also our topic list MontiCore project - MontiCore","title":"Languages"},{"location":"docs/DevelopedLanguages/#languages-and-language-components-that-have-been-developed-with-monticore","text":"The MontiCore language workbench has been under development already for a while and of course has old been used by our group to develop many other languages. Not all of those languages are of publicly available and some of these languages are equipped with tools based on MontiCore 5-. Some of these languages are monolithic, others are composed of each other. The available languages can also be used for adaptation, extension, and composition Please also have a look at our literature references for further information on many of the languages. MontiArc ADL is an architectural definition language for component and connector models with enhanced connection facilities, hierarchical decomposition etc. and provides a simulator [HRR12,BHH+17,Wor16,Hab16] . MontiArcAutomaton ADL is an extension of the architectural definition language MontiArc using automata to describe behavior. Some applications e.g. are of robotics, production, or InternetOfThings. [BKRW17a,HKR+16,BRW16a,Wor16] . UML/P is a derivation from UML, especially suited for agile development. See language definition and usage method in [Rum17,Rum16,Sch12] . UML/P Class Diagrams for data structures UML/P Object Diagrams for exemplaric situations: usable for constructive development as well as testing OCL/P as Java-variant of the OCL with a nice logic, set-comprehension etc. UML/P Statecharts for behavior UML/P Sequence Diagrams for interaction Activity Diagrams for workflows and requirements (an extension to the books) Delta-MontiArc [HRRS12,HKR+11,HRRS11] is a DSL for expressing deltas on MontiArc component definitions, which allows to model software product lines in a bottom up way. MontiArcHV [HRR+11] allows specifying component variability fully integrated within the component hierarchy located at variation points in component definitions. Java as full language as well as source for Java expressions, statements, attribute or method definitions. FeatureDSL is a DSL for feature diagrams in software product line approaches DeltaCD is a DSL for expressing deltas on class diagrams, which allows to model software product lines in a bottom up way Aerospace Constraint Specification Language is a DSL used to specify critical situations in an airspace including airplanes, weather, flight conditions and much more. [ZPK+11] clArc DSL Family: [PR13] Cloud Architecture Description Language: used to model of architectures of cloud-based systems; based on MontiArc. Target Description Language: used to model the infrastructure architecture of cloud-based systems. Mapping Description Language: used to model deployments between software and infrastructure architectures. Architecture Scenario Description Language: used to model scenario-based test cases for software architectures. I/O-TestDSL for the definition of stream-based, input-output related black-box tests for architecture definition languages like MontiArc. LightRocks , a modeling language for robotic assembly processes. cdViews is a DSL used to model partial views on class diagrams RBAC for Role-Based Access Control in enterprise information systems. MontiWis [[RR13,Rei16]] is a family of DSLs for the model-based, generative development of web information systems among others based on class diagrams, activity diagrams and views. HQL : Hibernate Query Language that maps to hibernate based executions. SQL the well known DB query language; used for embedding e.g. into other languages. XML the basic infrastructure for all XML dialects CarOLO DSLs for autonomic driving. This among others contains a DSL for defining road scenarios with moving vehicles as well a obstacles suited for laser, lidar, radar and camera sensors. This languages are part of the Darpa Urban Challenge 2007. [BR12b,BR12,Ber10,BR09] . ProcEd a Web-based Editing Solution for Domain Specific Process-Engineering [BGR09] . MontiWeb a modular development approach for Web Information Systems (which was later succeded by MontiWIS) [DRRS09] . C++ and its sublanguages for expressions, statements and definitions (but no generic types, no defines) MontiCore itself uses a family of DSLs for the definition of DSLs, i.e., their grammars. [HR17]","title":"Languages and Language Components that have been developed with MontiCore"},{"location":"docs/DevelopedLanguages/#further-languages-and-information","text":"MontiCore Online Demonstrator . (TODO: needs to be released) MontiCore Reference Manual . The reference Manual describes how to use MontiCore as a out-of-the-box language workbench ), but also as grey box tooling framework . It thus also gives an overview over a number of core mechanisms of MontiCore. List of core grammars . MontiCore concentrates on reuse. It therefore offers a set of predefined language components , usually identified through an appropriate component grammar allowing to define your own language as a composition of reusable assets efficiently. reusable assets are among others: several sets of literals , expressions and types , which are relatively freely composable. List of languages . This is a list of newer MontiCore 6 languages that can be used out of the box. Some of them are in development, others rather stable. These complete languages are usually composed of a number of language components. see also our literature list see also our topic list MontiCore project - MontiCore","title":"Further Languages and Information"},{"location":"docs/GettingStarted/","text":"MontiCore - Getting Started In the following you will learn how to get started with MontiCore. Before you start please make sure that Java is installed on your system as described in the prerequisites . Now that your system is ready you have three options to get started. Just choose one of the following guides: Command Line Eclipse IntelliJ Prerequisites Install the Java 8 JDK . Make sure the environment variable JAVA_HOME points to the installed JDK, NOT the JRE (e.g. \u2039/usr/lib/jvm/java-8-openjdk\u203a on UNIX or \u2039C:\\Program Files\\Java\\jdk1.8.0_51\u203a on Windows). You will need this in order to run the Java compiler for compiling the generated Java source files; see here for more information. Also make sure that the PATH variable is set such that the Java compiler is available. JDK installations on UNIX systems do this automatically. On Windows systems the \u2039bin\u203a directory of the JDK installation needs to be appended to the PATH variable, e.g. \u2039%PATH%;%JAVA_HOME%\\bin\u203a (see also here ). Command Line MontiCore supports different environments. For a quick peek, the command line version can be tried out with an exemplary automata DSL using the following instructions: In a nutshell Prerequisites Install the Java Development Kit (JDK) 8. Installation Download the MontiCore distribution file, unzip it, and change to the extracted directory. Running MontiCore Execute MontiCore on the provided language definition \u2039Automata.mc4\u203a. Compiling the Product Compile all the generated and supplied handwritten Java source files. Running the Product Execute the automata tool on an example model \u2039example/PingPong.aut\u203a. Detailed description Installation Download the MontiCore zip distribution file . Unzip the distribution. It will unzip a directory called \u2039mc-workspace\u203a containing the executable MontiCore CLI (short for command line interface) JAR along with a directory \u2039src\u203a containing handwritten automata DSL infrastructure, a directory \u2039hwc\u203a containing handwritten code that will be incorporated into the generated code, and a directory \u2039example\u203a containing an example automata model. Run MontiCore Open a command line interface and change to the unzipped directory \u2039mc-workspace\u203a). The distribution contains the sources of an automata DSL consisting of the automata grammar and handwritten Java files in the directory \u2039src\u203a. Execute the following command in order to generate the language infrastructure of the specified automata DSL: java -jar monticore-cli.jar Automata.mc4 -hcp hwc/ The only required argument \u2039Automata.mc4\u203a denotes the input grammar for MontiCore to process and generate the language infrastructure for. The second argument denotes the path to look for handwritten code that is to be incorporated into the generated infrastructure. MontiCore will be launched and the following steps will be executed: The specified grammar will be parsed and processed by MontiCore. Java source files for the corresponding DSL infrastructure will be generated into the default output directory \u2039out\u203a. This infrastructure consists of: out/automata/_ast containing the abstract syntax representation of the automata DSL. out/automata/_cocos containing infrastructure for context conditions of the automata DSL. out/automata/_od containing infrastructure for printing object diagrams of the automata DSL. out/automata/_parser containing the generated parsers which are based on ANTLR . out/automata/_symboltable containing infrastructure for the symbol table of the automata DSL. out/automata/_visitor containing infrastructure for visitors of the automata DSL. out/reports/Automata containing reports created during the processing of the automata grammar. The output directory will also contain a log file of the executed generation process \u2039monticore.YYYY-MM-DD-HHmmss.log\u203a. Compile and run Compiling the automata DSL Execute the command: javac -cp monticore-cli.jar -sourcepath \"src/;out/;hwc/\" src/automata/AutomataTool.java Please note: on Unix systems paths are separated using \":\" (colon) instead of semicolons. This will compile all generated classes located in \u2039out/\u203a and all handwritten classes located in \u2039src/\u203a and \u2039hwc/\u203a. Please note that the structure of the handwritten classes follows (though not necessarily) the package layout of the generated code, i.e. there are the following sub directories (Java packages): src/automata contains the top level language realization for using the generated DSL infrastructure. In this case the class \u2039src/automata/AutomataTool.java\u203a constitutes a main class executable for processing automata models with the automata DSL (inspect the class and see below for how to execute it). src/automata/cocos contains infrastructure for context condition of the automata DSL. src/automata/prettyprint contains an exemplary use of the generated visitor infrastructure for processing the parsed model. Here: for pretty printing. src/automata/visitors contains an exemplary analysis using the visitor infrastructure. The exemplary analysis counts the states contained in the parsed automata model. hwc/automata/_ast contains an exemplary usage of the handwritten code integration mechanism for modifying the AST for the automata DSL. hwc/automata/_symboltable contains handwritten extensions of the generated symbol table infrastructure. Running the automata DSL tool Execute the command: java -cp \"src/;out/;hwc/;monticore-cli.jar\" automata.AutomataTool example/PingPong.aut Please note: on Unix systems paths are separated using \":\" (colon) instead of semicolons. This will run the automata DSL tool. The argument \u2039example/PingPong.aut\u203a is passed to the automata DSL tool as input file. Examine the output on the command line which shows the processing of the example automata model. Experiment: The shipped example automata DSL (all sources contained in \u2039mc-workspace/src\u203a and \u2039mc-workspace/hwc\u203a) can be used as a starting point. It can easily be altered to specify your own DSL by adjusting the grammar and the handwritten Java sources and rerunning MontiCore as described above. Eclipse For getting started with MontiCore using Eclipse do the following: Setting up Eclipse Download and install Eclipse (or use an existing one) Open Eclipse Install needed Plugins Help > Install new Software Make sure the M2E (Maven 2 Eclipse) Plugin is installed M2E can be found here Install the following MontiCore M2E Extension found here: Install MontiCore 5 (or higher) extension Make sure to confire Eclipse to use a JDK instead of an JRE Window > Preferences > Java > Installed JREs Importing the Example Clone the github project or download the zip for the Automata Example here . Select File Import... Maven Existing Maven Projects Click next Click on the Browse.. button and use the folder holding the pom.xml Running MontiCore Right click on the project Run as > Maven install Add \u2039../target/generated-sources/monticore/sourcecode\u203a to your build path Right click on the folder > Build Path > Use as Source Folder MontiCore will be launched and the following steps will be executed: The specified grammar will be parsed and processed by MontiCore. Java source files for the corresponding DSL infrastructure will be generated into the default output directory \u2039../target/generated-sources/monticore/sourcecode\u203a. This infrastructure consists of: /automata/_ast containing the abstract syntax representation of the automata DSL. /automata/_cocos containing infrastructure for context conditions of the automata DSL. /automata/_od containing infrastructure for printing object diagrams of the automata DSL. /automata/_parser containing the generated parsers which are based on ANTLR . /automata/_symboltable containing infrastructure for the symbol table of the automata DSL. /automata/_visitor containing infrastructure for visitors of the automata DSL. /reports/Automata containing reports created during the processing of the automata grammar. The output directory will also contain a log file of the executed generation process \u2039monticore.YYYY-MM-DD-HHmmss.log\u203a. IntelliJ For getting started with MontiCore using IntelliJ do the following: Setting up IntelliJ IDEA Download and install IntelliJ IDEA (or use your existing installation) Hint for Students: You get the Ultimate version of IntelliJ for free Open IntelliJ IDEA Importing the Example Clone the github project or download the zip for the Automata Example here . Select File Open Select the folder holding the pom.xml Running MontiCore From the Maven Projects Menu on the right select Automata Lifecycle install (double click) MontiCore will be launched and the following steps will be executed: The specified grammar will be parsed and processed by MontiCore. Java source files for the corresponding DSL infrastructure will be generated into the default output directory \u2039../target/generated-sources/monticore/sourcecode\u203a. This infrastructure consists of: /automata/_ast containing the abstract syntax representation of the automata DSL. /automata/_cocos containing infrastructure for context conditions of the automata DSL. /automata/_od containing infrastructure for printing object diagrams of the automata DSL. /automata/_parser containing the generated parsers which are based on ANTLR . /automata/_symboltable containing infrastructure for the symbol table of the automata DSL. /automata/_visitor containing infrastructure for visitors of the automata DSL. /reports/Automata containing reports created during the processing of the automata grammar. The output directory will also contain a log file of the executed generation process \u2039monticore.YYYY-MM-DD-HHmmss.log\u203a. Troubleshooting If an error occurs and you cannot solve the problem you may take a look into the MontiCore log file located in the respectively specified output directory (e.g. \u2039out/monticore.YYYY-MM-DD-HHmmss.log\u203a by default). It contains more verbose and developer-oriented, technical output than the CLI output. Please report any unknown issues to bugreport@monticore.de . Please include the processed grammar, model, and the log file. Downloads MontiCore zip with automata DSL example Executable MontiCore Java archive (without example) Further Information see also MontiCore Reference Manual MontiCore project - MontiCore","title":"Getting Started"},{"location":"docs/GettingStarted/#monticore-getting-started","text":"In the following you will learn how to get started with MontiCore. Before you start please make sure that Java is installed on your system as described in the prerequisites . Now that your system is ready you have three options to get started. Just choose one of the following guides: Command Line Eclipse IntelliJ","title":"MontiCore - Getting Started"},{"location":"docs/GettingStarted/#prerequisites","text":"Install the Java 8 JDK . Make sure the environment variable JAVA_HOME points to the installed JDK, NOT the JRE (e.g. \u2039/usr/lib/jvm/java-8-openjdk\u203a on UNIX or \u2039C:\\Program Files\\Java\\jdk1.8.0_51\u203a on Windows). You will need this in order to run the Java compiler for compiling the generated Java source files; see here for more information. Also make sure that the PATH variable is set such that the Java compiler is available. JDK installations on UNIX systems do this automatically. On Windows systems the \u2039bin\u203a directory of the JDK installation needs to be appended to the PATH variable, e.g. \u2039%PATH%;%JAVA_HOME%\\bin\u203a (see also here ).","title":"Prerequisites"},{"location":"docs/GettingStarted/#command-line","text":"MontiCore supports different environments. For a quick peek, the command line version can be tried out with an exemplary automata DSL using the following instructions:","title":"Command Line"},{"location":"docs/GettingStarted/#in-a-nutshell","text":"Prerequisites Install the Java Development Kit (JDK) 8. Installation Download the MontiCore distribution file, unzip it, and change to the extracted directory. Running MontiCore Execute MontiCore on the provided language definition \u2039Automata.mc4\u203a. Compiling the Product Compile all the generated and supplied handwritten Java source files. Running the Product Execute the automata tool on an example model \u2039example/PingPong.aut\u203a.","title":"In a nutshell"},{"location":"docs/GettingStarted/#detailed-description","text":"","title":"Detailed description"},{"location":"docs/GettingStarted/#installation","text":"Download the MontiCore zip distribution file . Unzip the distribution. It will unzip a directory called \u2039mc-workspace\u203a containing the executable MontiCore CLI (short for command line interface) JAR along with a directory \u2039src\u203a containing handwritten automata DSL infrastructure, a directory \u2039hwc\u203a containing handwritten code that will be incorporated into the generated code, and a directory \u2039example\u203a containing an example automata model.","title":"Installation"},{"location":"docs/GettingStarted/#run-monticore","text":"Open a command line interface and change to the unzipped directory \u2039mc-workspace\u203a). The distribution contains the sources of an automata DSL consisting of the automata grammar and handwritten Java files in the directory \u2039src\u203a. Execute the following command in order to generate the language infrastructure of the specified automata DSL: java -jar monticore-cli.jar Automata.mc4 -hcp hwc/ The only required argument \u2039Automata.mc4\u203a denotes the input grammar for MontiCore to process and generate the language infrastructure for. The second argument denotes the path to look for handwritten code that is to be incorporated into the generated infrastructure. MontiCore will be launched and the following steps will be executed: The specified grammar will be parsed and processed by MontiCore. Java source files for the corresponding DSL infrastructure will be generated into the default output directory \u2039out\u203a. This infrastructure consists of: out/automata/_ast containing the abstract syntax representation of the automata DSL. out/automata/_cocos containing infrastructure for context conditions of the automata DSL. out/automata/_od containing infrastructure for printing object diagrams of the automata DSL. out/automata/_parser containing the generated parsers which are based on ANTLR . out/automata/_symboltable containing infrastructure for the symbol table of the automata DSL. out/automata/_visitor containing infrastructure for visitors of the automata DSL. out/reports/Automata containing reports created during the processing of the automata grammar. The output directory will also contain a log file of the executed generation process \u2039monticore.YYYY-MM-DD-HHmmss.log\u203a.","title":"Run MontiCore"},{"location":"docs/GettingStarted/#compile-and-run","text":"Compiling the automata DSL Execute the command: javac -cp monticore-cli.jar -sourcepath \"src/;out/;hwc/\" src/automata/AutomataTool.java Please note: on Unix systems paths are separated using \":\" (colon) instead of semicolons. This will compile all generated classes located in \u2039out/\u203a and all handwritten classes located in \u2039src/\u203a and \u2039hwc/\u203a. Please note that the structure of the handwritten classes follows (though not necessarily) the package layout of the generated code, i.e. there are the following sub directories (Java packages): src/automata contains the top level language realization for using the generated DSL infrastructure. In this case the class \u2039src/automata/AutomataTool.java\u203a constitutes a main class executable for processing automata models with the automata DSL (inspect the class and see below for how to execute it). src/automata/cocos contains infrastructure for context condition of the automata DSL. src/automata/prettyprint contains an exemplary use of the generated visitor infrastructure for processing the parsed model. Here: for pretty printing. src/automata/visitors contains an exemplary analysis using the visitor infrastructure. The exemplary analysis counts the states contained in the parsed automata model. hwc/automata/_ast contains an exemplary usage of the handwritten code integration mechanism for modifying the AST for the automata DSL. hwc/automata/_symboltable contains handwritten extensions of the generated symbol table infrastructure. Running the automata DSL tool Execute the command: java -cp \"src/;out/;hwc/;monticore-cli.jar\" automata.AutomataTool example/PingPong.aut Please note: on Unix systems paths are separated using \":\" (colon) instead of semicolons. This will run the automata DSL tool. The argument \u2039example/PingPong.aut\u203a is passed to the automata DSL tool as input file. Examine the output on the command line which shows the processing of the example automata model.","title":"Compile and run"},{"location":"docs/GettingStarted/#experiment","text":"The shipped example automata DSL (all sources contained in \u2039mc-workspace/src\u203a and \u2039mc-workspace/hwc\u203a) can be used as a starting point. It can easily be altered to specify your own DSL by adjusting the grammar and the handwritten Java sources and rerunning MontiCore as described above.","title":"Experiment:"},{"location":"docs/GettingStarted/#eclipse","text":"For getting started with MontiCore using Eclipse do the following:","title":"Eclipse"},{"location":"docs/GettingStarted/#setting-up-eclipse","text":"Download and install Eclipse (or use an existing one) Open Eclipse Install needed Plugins Help > Install new Software Make sure the M2E (Maven 2 Eclipse) Plugin is installed M2E can be found here Install the following MontiCore M2E Extension found here: Install MontiCore 5 (or higher) extension Make sure to confire Eclipse to use a JDK instead of an JRE Window > Preferences > Java > Installed JREs","title":"Setting up Eclipse"},{"location":"docs/GettingStarted/#importing-the-example","text":"Clone the github project or download the zip for the Automata Example here . Select File Import... Maven Existing Maven Projects Click next Click on the Browse.. button and use the folder holding the pom.xml","title":"Importing the Example"},{"location":"docs/GettingStarted/#running-monticore","text":"Right click on the project Run as > Maven install Add \u2039../target/generated-sources/monticore/sourcecode\u203a to your build path Right click on the folder > Build Path > Use as Source Folder MontiCore will be launched and the following steps will be executed: The specified grammar will be parsed and processed by MontiCore. Java source files for the corresponding DSL infrastructure will be generated into the default output directory \u2039../target/generated-sources/monticore/sourcecode\u203a. This infrastructure consists of: /automata/_ast containing the abstract syntax representation of the automata DSL. /automata/_cocos containing infrastructure for context conditions of the automata DSL. /automata/_od containing infrastructure for printing object diagrams of the automata DSL. /automata/_parser containing the generated parsers which are based on ANTLR . /automata/_symboltable containing infrastructure for the symbol table of the automata DSL. /automata/_visitor containing infrastructure for visitors of the automata DSL. /reports/Automata containing reports created during the processing of the automata grammar. The output directory will also contain a log file of the executed generation process \u2039monticore.YYYY-MM-DD-HHmmss.log\u203a.","title":"Running MontiCore"},{"location":"docs/GettingStarted/#intellij","text":"For getting started with MontiCore using IntelliJ do the following:","title":"IntelliJ"},{"location":"docs/GettingStarted/#setting-up-intellij-idea","text":"Download and install IntelliJ IDEA (or use your existing installation) Hint for Students: You get the Ultimate version of IntelliJ for free Open IntelliJ IDEA","title":"Setting up IntelliJ IDEA"},{"location":"docs/GettingStarted/#importing-the-example_1","text":"Clone the github project or download the zip for the Automata Example here . Select File Open Select the folder holding the pom.xml","title":"Importing the Example"},{"location":"docs/GettingStarted/#running-monticore_1","text":"From the Maven Projects Menu on the right select Automata Lifecycle install (double click) MontiCore will be launched and the following steps will be executed: The specified grammar will be parsed and processed by MontiCore. Java source files for the corresponding DSL infrastructure will be generated into the default output directory \u2039../target/generated-sources/monticore/sourcecode\u203a. This infrastructure consists of: /automata/_ast containing the abstract syntax representation of the automata DSL. /automata/_cocos containing infrastructure for context conditions of the automata DSL. /automata/_od containing infrastructure for printing object diagrams of the automata DSL. /automata/_parser containing the generated parsers which are based on ANTLR . /automata/_symboltable containing infrastructure for the symbol table of the automata DSL. /automata/_visitor containing infrastructure for visitors of the automata DSL. /reports/Automata containing reports created during the processing of the automata grammar. The output directory will also contain a log file of the executed generation process \u2039monticore.YYYY-MM-DD-HHmmss.log\u203a.","title":"Running MontiCore"},{"location":"docs/GettingStarted/#troubleshooting","text":"If an error occurs and you cannot solve the problem you may take a look into the MontiCore log file located in the respectively specified output directory (e.g. \u2039out/monticore.YYYY-MM-DD-HHmmss.log\u203a by default). It contains more verbose and developer-oriented, technical output than the CLI output. Please report any unknown issues to bugreport@monticore.de . Please include the processed grammar, model, and the log file.","title":"Troubleshooting"},{"location":"docs/GettingStarted/#downloads","text":"MontiCore zip with automata DSL example Executable MontiCore Java archive (without example)","title":"Downloads"},{"location":"docs/GettingStarted/#further-information","text":"see also MontiCore Reference Manual MontiCore project - MontiCore","title":"Further Information"},{"location":"docs/Languages/","text":"MontiCore Languages - an Overview [[ TOC ]] MontiCore is a language workbench with an explicit notion of language components. It uses grammars to describe textual DSLs. MontiCore uses an extended grammar format that allows to compose language components via inheritance, embedding and aggregation (see the reference manual for details). A language component is mainly represented through (1) the grammar describing concrete and abstract syntax of the language, (2) Java-classes implementing specific functionalities, and (3) Freemarker-Templates helping to print a model to text. However, language components are often identified with their main component grammar. Language components are currently organized in two levels: In this list you mainly find grammars for complete (but also reusable and adaptable) languages . A list of grammar components with individual reusable nonterminals is also available in the MontiCore core project ( development status ). The following list contains the language grammars found in the MontiCore projects, such as cd4analysis/cd4analysis . They are usually contained in project folders like src/main/grammars/ and organized in packages like de.monticore.cd . MontiCore projects are hosted at https://git.rwth-aachen.de/monticore , and partially also at https://github.com/MontiCore/ List of Languages Class Diagram For Analysis (CD4A) (Beta: In Stabilization) Responsible: SVa, AGe CD4A is the textual representation to describe UML class diagrams (it uses the UML/P variant). CD4A covers classes, interfaces, inheritance, attributes with types, visibilities , and all kinds of associations and composition , including qualified and ordered associations . An example: ``` classdiagram MyLife { abstract class Person { int age; Date birthday; List nickNames; } < > class Student extends Person { StudentStatus status; } enum StudentStatus { ENROLLED, FINISHED; } composition Person -> Address [ ] {ordered}; association [0..2] Person (parent) <-> (child) Person [ ]; association phonebook Person [String] -> TelefoneNumber ; } `` * CD4A focusses on the analysis phase in typical data-driven development projects and is therefore mainly for data modelling. Consequently, it omits method signatures and complex generics. CD4A primary use is therefore **data modelling**. It has various possibilities for generation of data structures, database tables as well as data transport infrastructures in cloud and distributed systems. * [Main grammar de.monticore.cd.CD4Analysis`](https://git.rwth-aachen.de/monticore/cd4analysis/cd4analysis/blob/develop/src/main/grammars/de/monticore/cd/CD4Analysis.mc4) and detailed description Class Diagram for Code (CD4Code) (Beta: In Stabilization) Responsible: SVa, AGe CD4Code describes UML class diagrams . CD4Code is a conservative extension of CD4A , which includes method signatures. An example: classdiagram MyLife2 { // like CD4A but also allows: class Person { protected List<Person> closestFriends(int n); void addFriend(Person friends...); } } CD4Code is often used as tool-internal AST that allows to map any kind of source models to a class/attribute/method/association based intermediate structure, before it is printed e.g. as Java code. For example a transformation sequence could be: Statechart -> State pattern encoded in CD4Code -> Decoration by monitoring methods -> Java code. Main grammar de.monticore.cd.CD4Code and detailed description (see Section CD4Code ) Feature Diagrams (Beta: In Stabilization) Caretaker: AB, DS Language for feature models and feature configurations. Feature diagrams are used to model (software) product lines and their variants . Feature configurations select a subset of features of a feature model to describe a product of the product line. An example: ``` featurediagram MyPhones { Phone -> Memory & OS & Camera? & Screen; Memory -> Internal & External?; Internal -> [1..2] of {Small, Medium, Large}; OS -> iOS ^ Android; Screen -> Flexible | FullHD; Camera requires (iOS && External) || Android ; } `` Rules F -> ... have a parent feature (left-hand side) and its child features (right-hand side). Operators are: **optional** feature ? , **and** & , **or** | , **xor** ^ , and **subset cardinality** constraints, like [1..2] of ... . Further, a feature model may define cross-tree constraints using logic operators **and** && , **or** || , **implication** requires , etc. * Main grammar [ FeatureDiagram`](https://git.rwth-aachen.de/monticore/languages/feature-diagram/-/blob/master/fd-lang/src/main/grammars/FeatureDiagram.mc4) and detailed description GUI DSL (Alpha: Intention to become stable) Caretaker: LN Language for textual definition of Graphical User Interfaces of Web Applications GUI DSL covers GUI elements and relevant configuration, which include layout elements, widgets , their style definition and references to data sources . Language is mainly used to describe GUI of Web Applications . The models of the language represent graphical views or their parts, omitting smaller details of style definition and simplifying connection between graphical elements and data sources. Examples: MaCoCo , Ford Main grammar GUIDSL includes definitions of MontiGem visualisation components, which are based on abstract concepts, described in core grammar GUIDSLCore . Detailed description and documentation . MontiCore Grammar (MontiCore Stable) Caretaker: MB Language for MontiCore Grammars itself. It can be understood as meta language , but also used as ordinary language. Its main use currently: A MontiCore grammar defines the concrete syntax and the abstract syntax of a textual language. Examples: All languages on this page are defined using MontiCore grammars and thus conform to this Grammar. Main features: Define nonterminals and their productions in EBNF, lexical token as regular expressions. Most important extensions to standard grammars: Abstract , interface and external productions allow to define extensible component grammars (object-oriented grammar style). Inherited productions can be redefined (overwritten) as well as conservatively extended. Symbol and scope infrastructure is defined by simple keywords. Symbols definition places can be introduced and symbol referencing places defined, such that for standard cases automatically symbol tables can be added. Additional attributes and methods can be added to the abstract syntax only. Various elements, such as semantic predicates and actions can be defined in the same style as the underlying ANTLR. MontiCore grammars can be left recursive and even allow mutual recursion. This is e.g. useful for expression hierarchies. Additional elements, such as enum productions and comfortable operations for grammar definitions exist. Main grammars de.monticore.grammar.Grammar defines the language with some open parameters and de.monticore.grammar.Grammar_WithConcepts binds the external, imported expressions, method bodies, etc. Detailed description in the MontiCore Reference Manual. JSON (MontiCore Stable) Responsible: NJ The MontiCore language for parsing JSON artifacts. An example: { \"Alice\": { \"fullname\": \"Alice Anderson\", \"address\": { \"postal_code\": 10459, \"street\": \"Beck Street\", \"number\": 56 } }, \"Bob\": { ... }, \"Caroll\": { ... }, ... } The JSON grammar adheres to the common JSON standard and allows parsing arbitrary JSON artifacts for further processing. Actually the grammar represents a slight superset to the official JSON standard. It is intended for parsing JSON-compliant artifacts. Further well-formedness checks are not included, because we assume to parse correctly produced JSON documents only. Please note that JSON (like XML or ASCII) is primarily a carrier language. The concrete JSON dialect and the question, how to recreate the real objects / data structures, etc. behind the JSON tree structure is beyond this grammar, but can be applied to the AST defined here. Main grammar de.monticore.lang.JSON and detailed description MontiArc (Beta: In Stabilization) Caretaker: DS MontiArc is an architecture and behavior modeling language and framework that provides an platform independent structure and behavior modeling language with an extensible code generation framework. MontiArc covers components their ports , connectors between components and embedded statecharts for component behavior description. Statecharts define states and transitions with conditions on the incoming messages as well as transition actions. An example: component InteriorLight { // MontiArc language port in Boolean lightSignal, // ports in Boolean doorSignal out OnOff status; ORGate or; // used subcomponents lightSignal -> or.a; // connectors doorSignal -> or.b; or.c -> cntr.signal; component LightController cntr { // freshly defined subcomponent port in OnOff signal, out OnOff status; statechart { // with behavior by a Statechart initial state Off / {status = OFF}; state On; Off -> On [ signal == true ] / {status = ON} On -> Off [ signal == false ] / {status = OFF} } } cntr.status -> status; } MontiArcs main goal is to provide a textual notation for Component&Connector diagrams, which is used quite often in various variants in industry. E.g. SysML's BDD, UML's component composition diagrams use the same paradigm. MontiArc does not define data types for their signals, but assumes that these types can be imported (e.g. from a class diagram). MontiArc itself also has no timing predefined, but for a complete language a concrete timing, such as formally grounded by Focus, should be added. Main grammar MontiArc.mc4 and detailed description OCL/P (Alpha: Intention to become stable) Caretaker: SVa OCL/P is the textual representation of the UML OCL standard, adapted with Java-like syntax. It's main goal is the usage in combination with other languages like CD4A or Object Diagrams as an integrated part of that languages. OCL/P allows to define invariants and pre/post conditions in the known OCL style. Furthermore, it offers a large set expressions to model constraints. These expressions include Java expressions , set operations , list operations etc., completely covering the OCL standard concepts, but extend it e.g. by set comprehensions known from Haskell, a typesafe cast or a transitive closure operator . OCL/P comes with an OCL to Java generator and a second generator for OCL in combination with Embedded MontiArc . Main grammar ocl.monticoreocl.OCL and detailed description Object Diagrams (Beta: In Stabilization) Caretaker: SH OD is a language for textual denotation of object diagrams. The OD language has several purposes (when combined with appropriate language extensions): specification language for object structures (as part of the UML/P ) stage and transport of data sets (e.g. the artifact analysis toolchain), and as a report format for the MontiCore tool infrastructure. OD covers named and anonymous objects, links, attributes, attribute values, lists , and visibilities . For a comfortable definition, objects may be nested. An example: objectdiagram MyFamily { alice:Person { age = 29; cars = [ :BMW { color = BLUE; }, tiger:Jaguar { color = RED; length = 5.3; } ]; }; bob:Person { nicknames = [\"Bob\", \"Bobby\", \"Robert\"]; cars = [tiger]; }; link married alice <-> bob; } If ODs are used as specification techniqe, e.g. for tests or unwanted situations, a more expressive version of expressions can be used for values (e.g. by composing ODs with JavaExpressions). Furthermore, only interesting attributes need to be defined (underspecification) and conformity to a CD4A model can be checked. The ODs differ from JSON structures, e.g., in the possibility to give the object a name as it is the case for tiger , or alice enabaling the definition real graph structures. Main grammars: ODBasics OD4Report DateLiterals Detailed description Sequence Diagrams (MontiCore stable) Caretaker: RE Grammar to parse Sequence Diagrams Can be used with testing generator to derive test cases SI Units (Beta: In Stabilization) Caretaker: EK The international system of units (SI units) is a physical unit system widely used in the entire world. It is based on the basis units s, m, kg, A, K, mol, cd , provides a variety of derived units, and can be refined using prefixes such as m (milli), k (kilo), etc. The SI Unit project aims to deliver SI units to MontiCore-based languages. It provides a grammar for all types of SI units and prefixes. Second, we provide the SI Unit literals, such as \"5 km\" as expression values and a language for SI unit types, such as \"km/h\" or \"km/h \". Some examples: km/h speed = 5 m / 27 s // variable definition speed = (3 * 4m + 17km/h * 10h) / 3.5 h // assignment \u00b0C/s<float> coolingSpeed; g/mm^2<int> pressure; Map<Location,\u00b0C> temperatures; The SI unit literals integrate with MontiCore's expressions and the SI Unit types integrate with MontiCore's type system. The SI unit language remains type safe. Main grammar components: SI units SI unit literals SI unit types for math SI unit types for computations (other alternatives are possible; SI has not standardized anything here) Example projects: SI Java detailed description Statecharts (Beta: In Stabilization) (90% to MC6) Caretaker: RE supported by KH Language to parse Statecharts creates transformation language within SC and sc<->cd4a Detailed description A compact teaser for the Statechart language: ``` statechart Door { state Opened initial state Closed state Locked Opened -> Closed close() / Closed -> Opened open() / {ringTheDoorBell();} Closed -> Locked timeOut() / { lockDoor(); } [doorIsLocked] Locked -> Closed [isAuthorized] unlock() / } `` This example models the different states of a door: Opened , Closed , and Locked . When the statechart is in state Opened , it is possible to close the door using close() . When the statechart is in state Closed , it is possible to open the door using open() . In the latter case the action ringDoorBell() is executed. When the door is Closed it is automatically locked after some time due to a timeout() event that triggers the lockDoor() action. Consequently, the post-condition doorIsLocked holds. In case the door is locked, it can be unlocked by using unlock() if the pre-condition isAuthorized` is fulfilled. SysML_2 (Alpha: Intention to become stable) Caretaker: NJ MontiCore languages for parsing artifacts of the SysML 2 language famlily. Examples: package 'Vehicles' { // a SysML block diagram private import ScalarValues::*; block Vehicle; block Truck is Vehicle; value type Torque is ISQ::TorqueValue; } package 'Coffee' { // a SysML activity diagram activity BrewCoffee (in beans : CoffeeBeans, in, water : Water, out coffee : Coffee) { bind grind::beans = beans; action grind : Grind (in beans, out powder); flow grind::powder to brew::powder; bind brew::water = water; action brew : Brew (in powder, in water, out coffee); bind brew::coffee = coffee; } } The SysML 2 grammars adhere to the general upcoming SysML 2 specification (which is still under improvement currently). Actually these grammars represents a slight superset to the official SysML 2 standard. It is intended for parsing SysML 2-compliant models. Well-formedness checks are kept to a minimum, because we assume to parse correctly produced SysML 2 models only. MontiCore's SysML 2 is a language familiy that comes with a textual representation to describe SysML 2 diagrams with respect to the standard. SysML 2 covers ADs , BDDs , IBDs , PackageDiagrams , ParametricDiagrams , RequirementDiagrams , SDs , SMDs , UseCaseDiagrams , and general SysMLBasics Main grammars and detailed description Tagging (Alpha: Intention to become stable) Caretaker: SVa Tags are known e.g. from the UML and SysML and mainly used to add extra information to a model element. Normally tags (and stereotypes ) are inserted within the models, which over time polutes the models, especially when different sets of tags are needed for different technical platforms. MontiCore offers a solution that separates a model and its tags into distinct artifacts . Several independent tagging artifacts can be added without any need to adapt the core model. This allows fo reuse even of fixed library models. The tagging artifacts are dependent on two factors: First, tags can be added to named elements of the base model. It is of great help that we have an elegant symbol mechanism included in the MontiCore generator. Second, the set of allowed tags can be constrained, by an explicit definition of allowed tag types and tag values and an explicit declaration on which kinds of symbols a tag may be attached to. Consequently tagging is not a single language, but a method to automatically and schematically derive languages: A tagging schema language TSL (dependent on the available symbol types of the base grammar) a tagging language TL (dependent on the tag schema models written in TSL) Because tagging models can e.g. be used as configuration techniques in a code generator, appropriate infrastructure is generated as well. Some tagging language examples Although concrete languages (and their grammars) are themselves generated, there is a main grammar ocl.monticore.lang.Tagging , where the tagging language is derived from. See also detailed description XML (Alpha: Intention to become stable) Responsible: NJ The MontiCore language for parsing XML artifacts. An example: <Calendar> <Appointment name=\"lunch\"> <Date>24.04.2020</Date> <Time>11:30</Time> <Location>cafeteria</Location> </Appointment> </Calendar> The XML grammar adheres to the common XML standard and allows parsing arbitrary XML artifacts for further processing. Actually the grammar represents a slight superset to the official XML standard. It is intended for parsing XML-compliant artifacts. Further well-formedness checks are not included, because we assume to parse correctly produced XML documents only. Please note that XML (like JSON or ASCII) is mainly a carrier language. The concrete XML dialect and the question, how to recreate the real objects / data structures, etc. behind the XML structure is beyond this grammar, but can be applied to the AST defined here. Main grammar de.monticore.lang.XML and detailed description JavaLight (Beta: In Stabilization) Caretaker: MB This is a reduced version of the Java language . JavaLight is meant to be used to integrate simplified Java-like parts in modeling languages but not to parse complete Java implementations. It provides Java's attribute and method definitions , statements and expressions , but does not provide class or interface definitions and also no wildcards in the type system. One main usage of JavaLight is in the Grammar-language to model e.g. Java methods. An example: public void print(String name) { System.out.println(\"Hello \" + name); } [Main grammar de.monticore.JavaLight ]((https://git.rwth-aachen.de/monticore/monticore/blob/dev/monticore-grammar/src/main/grammars/de/monticore/JavaLight.mc4) and detailed description . Java (Beta: In Stabilization) (30% to MC6) Caretaker: MB This is the full Java' Language (as Opposed to JavaLight). Main Grammar JavaDSL and detailed description . Further Information Project root: MontiCore @github MontiCore documentation Licence definition","title":"Languages"},{"location":"docs/Languages/#monticore-languages-an-overview","text":"[[ TOC ]] MontiCore is a language workbench with an explicit notion of language components. It uses grammars to describe textual DSLs. MontiCore uses an extended grammar format that allows to compose language components via inheritance, embedding and aggregation (see the reference manual for details). A language component is mainly represented through (1) the grammar describing concrete and abstract syntax of the language, (2) Java-classes implementing specific functionalities, and (3) Freemarker-Templates helping to print a model to text. However, language components are often identified with their main component grammar. Language components are currently organized in two levels: In this list you mainly find grammars for complete (but also reusable and adaptable) languages . A list of grammar components with individual reusable nonterminals is also available in the MontiCore core project ( development status ). The following list contains the language grammars found in the MontiCore projects, such as cd4analysis/cd4analysis . They are usually contained in project folders like src/main/grammars/ and organized in packages like de.monticore.cd . MontiCore projects are hosted at https://git.rwth-aachen.de/monticore , and partially also at https://github.com/MontiCore/","title":"MontiCore Languages - an Overview"},{"location":"docs/Languages/#list-of-languages","text":"","title":"List of Languages"},{"location":"docs/Languages/#class-diagram-for-analysis-cd4a-beta-in-stabilization","text":"Responsible: SVa, AGe CD4A is the textual representation to describe UML class diagrams (it uses the UML/P variant). CD4A covers classes, interfaces, inheritance, attributes with types, visibilities , and all kinds of associations and composition , including qualified and ordered associations . An example: ``` classdiagram MyLife { abstract class Person { int age; Date birthday; List nickNames; } < > class Student extends Person { StudentStatus status; } enum StudentStatus { ENROLLED, FINISHED; } composition Person -> Address [ ] {ordered}; association [0..2] Person (parent) <-> (child) Person [ ]; association phonebook Person [String] -> TelefoneNumber ; } `` * CD4A focusses on the analysis phase in typical data-driven development projects and is therefore mainly for data modelling. Consequently, it omits method signatures and complex generics. CD4A primary use is therefore **data modelling**. It has various possibilities for generation of data structures, database tables as well as data transport infrastructures in cloud and distributed systems. * [Main grammar de.monticore.cd.CD4Analysis`](https://git.rwth-aachen.de/monticore/cd4analysis/cd4analysis/blob/develop/src/main/grammars/de/monticore/cd/CD4Analysis.mc4) and detailed description","title":"Class Diagram For Analysis (CD4A) (Beta: In Stabilization)"},{"location":"docs/Languages/#class-diagram-for-code-cd4code-beta-in-stabilization","text":"Responsible: SVa, AGe CD4Code describes UML class diagrams . CD4Code is a conservative extension of CD4A , which includes method signatures. An example: classdiagram MyLife2 { // like CD4A but also allows: class Person { protected List<Person> closestFriends(int n); void addFriend(Person friends...); } } CD4Code is often used as tool-internal AST that allows to map any kind of source models to a class/attribute/method/association based intermediate structure, before it is printed e.g. as Java code. For example a transformation sequence could be: Statechart -> State pattern encoded in CD4Code -> Decoration by monitoring methods -> Java code. Main grammar de.monticore.cd.CD4Code and detailed description (see Section CD4Code )","title":"Class Diagram for Code (CD4Code) (Beta: In Stabilization)"},{"location":"docs/Languages/#feature-diagrams-beta-in-stabilization","text":"Caretaker: AB, DS Language for feature models and feature configurations. Feature diagrams are used to model (software) product lines and their variants . Feature configurations select a subset of features of a feature model to describe a product of the product line. An example: ``` featurediagram MyPhones { Phone -> Memory & OS & Camera? & Screen; Memory -> Internal & External?; Internal -> [1..2] of {Small, Medium, Large}; OS -> iOS ^ Android; Screen -> Flexible | FullHD; Camera requires (iOS && External) || Android ; } `` Rules F -> ... have a parent feature (left-hand side) and its child features (right-hand side). Operators are: **optional** feature ? , **and** & , **or** | , **xor** ^ , and **subset cardinality** constraints, like [1..2] of ... . Further, a feature model may define cross-tree constraints using logic operators **and** && , **or** || , **implication** requires , etc. * Main grammar [ FeatureDiagram`](https://git.rwth-aachen.de/monticore/languages/feature-diagram/-/blob/master/fd-lang/src/main/grammars/FeatureDiagram.mc4) and detailed description","title":"Feature Diagrams (Beta: In Stabilization)"},{"location":"docs/Languages/#gui-dsl-alpha-intention-to-become-stable","text":"Caretaker: LN Language for textual definition of Graphical User Interfaces of Web Applications GUI DSL covers GUI elements and relevant configuration, which include layout elements, widgets , their style definition and references to data sources . Language is mainly used to describe GUI of Web Applications . The models of the language represent graphical views or their parts, omitting smaller details of style definition and simplifying connection between graphical elements and data sources. Examples: MaCoCo , Ford Main grammar GUIDSL includes definitions of MontiGem visualisation components, which are based on abstract concepts, described in core grammar GUIDSLCore . Detailed description and documentation .","title":"GUI DSL (Alpha: Intention to become stable)"},{"location":"docs/Languages/#monticore-grammar-monticore-stable","text":"Caretaker: MB Language for MontiCore Grammars itself. It can be understood as meta language , but also used as ordinary language. Its main use currently: A MontiCore grammar defines the concrete syntax and the abstract syntax of a textual language. Examples: All languages on this page are defined using MontiCore grammars and thus conform to this Grammar. Main features: Define nonterminals and their productions in EBNF, lexical token as regular expressions. Most important extensions to standard grammars: Abstract , interface and external productions allow to define extensible component grammars (object-oriented grammar style). Inherited productions can be redefined (overwritten) as well as conservatively extended. Symbol and scope infrastructure is defined by simple keywords. Symbols definition places can be introduced and symbol referencing places defined, such that for standard cases automatically symbol tables can be added. Additional attributes and methods can be added to the abstract syntax only. Various elements, such as semantic predicates and actions can be defined in the same style as the underlying ANTLR. MontiCore grammars can be left recursive and even allow mutual recursion. This is e.g. useful for expression hierarchies. Additional elements, such as enum productions and comfortable operations for grammar definitions exist. Main grammars de.monticore.grammar.Grammar defines the language with some open parameters and de.monticore.grammar.Grammar_WithConcepts binds the external, imported expressions, method bodies, etc. Detailed description in the MontiCore Reference Manual.","title":"MontiCore Grammar (MontiCore Stable)"},{"location":"docs/Languages/#json-monticore-stable","text":"Responsible: NJ The MontiCore language for parsing JSON artifacts. An example: { \"Alice\": { \"fullname\": \"Alice Anderson\", \"address\": { \"postal_code\": 10459, \"street\": \"Beck Street\", \"number\": 56 } }, \"Bob\": { ... }, \"Caroll\": { ... }, ... } The JSON grammar adheres to the common JSON standard and allows parsing arbitrary JSON artifacts for further processing. Actually the grammar represents a slight superset to the official JSON standard. It is intended for parsing JSON-compliant artifacts. Further well-formedness checks are not included, because we assume to parse correctly produced JSON documents only. Please note that JSON (like XML or ASCII) is primarily a carrier language. The concrete JSON dialect and the question, how to recreate the real objects / data structures, etc. behind the JSON tree structure is beyond this grammar, but can be applied to the AST defined here. Main grammar de.monticore.lang.JSON and detailed description","title":"JSON (MontiCore Stable)"},{"location":"docs/Languages/#montiarc-beta-in-stabilization","text":"Caretaker: DS MontiArc is an architecture and behavior modeling language and framework that provides an platform independent structure and behavior modeling language with an extensible code generation framework. MontiArc covers components their ports , connectors between components and embedded statecharts for component behavior description. Statecharts define states and transitions with conditions on the incoming messages as well as transition actions. An example: component InteriorLight { // MontiArc language port in Boolean lightSignal, // ports in Boolean doorSignal out OnOff status; ORGate or; // used subcomponents lightSignal -> or.a; // connectors doorSignal -> or.b; or.c -> cntr.signal; component LightController cntr { // freshly defined subcomponent port in OnOff signal, out OnOff status; statechart { // with behavior by a Statechart initial state Off / {status = OFF}; state On; Off -> On [ signal == true ] / {status = ON} On -> Off [ signal == false ] / {status = OFF} } } cntr.status -> status; } MontiArcs main goal is to provide a textual notation for Component&Connector diagrams, which is used quite often in various variants in industry. E.g. SysML's BDD, UML's component composition diagrams use the same paradigm. MontiArc does not define data types for their signals, but assumes that these types can be imported (e.g. from a class diagram). MontiArc itself also has no timing predefined, but for a complete language a concrete timing, such as formally grounded by Focus, should be added. Main grammar MontiArc.mc4 and detailed description","title":"MontiArc (Beta: In Stabilization)"},{"location":"docs/Languages/#oclp-alpha-intention-to-become-stable","text":"Caretaker: SVa OCL/P is the textual representation of the UML OCL standard, adapted with Java-like syntax. It's main goal is the usage in combination with other languages like CD4A or Object Diagrams as an integrated part of that languages. OCL/P allows to define invariants and pre/post conditions in the known OCL style. Furthermore, it offers a large set expressions to model constraints. These expressions include Java expressions , set operations , list operations etc., completely covering the OCL standard concepts, but extend it e.g. by set comprehensions known from Haskell, a typesafe cast or a transitive closure operator . OCL/P comes with an OCL to Java generator and a second generator for OCL in combination with Embedded MontiArc . Main grammar ocl.monticoreocl.OCL and detailed description","title":"OCL/P (Alpha: Intention to become stable)"},{"location":"docs/Languages/#object-diagrams-beta-in-stabilization","text":"Caretaker: SH OD is a language for textual denotation of object diagrams. The OD language has several purposes (when combined with appropriate language extensions): specification language for object structures (as part of the UML/P ) stage and transport of data sets (e.g. the artifact analysis toolchain), and as a report format for the MontiCore tool infrastructure. OD covers named and anonymous objects, links, attributes, attribute values, lists , and visibilities . For a comfortable definition, objects may be nested. An example: objectdiagram MyFamily { alice:Person { age = 29; cars = [ :BMW { color = BLUE; }, tiger:Jaguar { color = RED; length = 5.3; } ]; }; bob:Person { nicknames = [\"Bob\", \"Bobby\", \"Robert\"]; cars = [tiger]; }; link married alice <-> bob; } If ODs are used as specification techniqe, e.g. for tests or unwanted situations, a more expressive version of expressions can be used for values (e.g. by composing ODs with JavaExpressions). Furthermore, only interesting attributes need to be defined (underspecification) and conformity to a CD4A model can be checked. The ODs differ from JSON structures, e.g., in the possibility to give the object a name as it is the case for tiger , or alice enabaling the definition real graph structures. Main grammars: ODBasics OD4Report DateLiterals Detailed description","title":"Object Diagrams (Beta: In Stabilization)"},{"location":"docs/Languages/#sequence-diagrams-monticore-stable","text":"Caretaker: RE Grammar to parse Sequence Diagrams Can be used with testing generator to derive test cases","title":"Sequence Diagrams  (MontiCore stable)"},{"location":"docs/Languages/#si-units-beta-in-stabilization","text":"Caretaker: EK The international system of units (SI units) is a physical unit system widely used in the entire world. It is based on the basis units s, m, kg, A, K, mol, cd , provides a variety of derived units, and can be refined using prefixes such as m (milli), k (kilo), etc. The SI Unit project aims to deliver SI units to MontiCore-based languages. It provides a grammar for all types of SI units and prefixes. Second, we provide the SI Unit literals, such as \"5 km\" as expression values and a language for SI unit types, such as \"km/h\" or \"km/h \". Some examples: km/h speed = 5 m / 27 s // variable definition speed = (3 * 4m + 17km/h * 10h) / 3.5 h // assignment \u00b0C/s<float> coolingSpeed; g/mm^2<int> pressure; Map<Location,\u00b0C> temperatures; The SI unit literals integrate with MontiCore's expressions and the SI Unit types integrate with MontiCore's type system. The SI unit language remains type safe. Main grammar components: SI units SI unit literals SI unit types for math SI unit types for computations (other alternatives are possible; SI has not standardized anything here) Example projects: SI Java detailed description","title":"SI Units (Beta: In Stabilization)"},{"location":"docs/Languages/#statecharts-beta-in-stabilization-90-to-mc6","text":"Caretaker: RE supported by KH Language to parse Statecharts creates transformation language within SC and sc<->cd4a Detailed description A compact teaser for the Statechart language: ``` statechart Door { state Opened initial state Closed state Locked Opened -> Closed close() / Closed -> Opened open() / {ringTheDoorBell();} Closed -> Locked timeOut() / { lockDoor(); } [doorIsLocked] Locked -> Closed [isAuthorized] unlock() / } `` This example models the different states of a door: Opened , Closed , and Locked . When the statechart is in state Opened , it is possible to close the door using close() . When the statechart is in state Closed , it is possible to open the door using open() . In the latter case the action ringDoorBell() is executed. When the door is Closed it is automatically locked after some time due to a timeout() event that triggers the lockDoor() action. Consequently, the post-condition doorIsLocked holds. In case the door is locked, it can be unlocked by using unlock() if the pre-condition isAuthorized` is fulfilled.","title":"Statecharts (Beta: In Stabilization) (90% to MC6)"},{"location":"docs/Languages/#sysml_2-alpha-intention-to-become-stable","text":"Caretaker: NJ MontiCore languages for parsing artifacts of the SysML 2 language famlily. Examples: package 'Vehicles' { // a SysML block diagram private import ScalarValues::*; block Vehicle; block Truck is Vehicle; value type Torque is ISQ::TorqueValue; } package 'Coffee' { // a SysML activity diagram activity BrewCoffee (in beans : CoffeeBeans, in, water : Water, out coffee : Coffee) { bind grind::beans = beans; action grind : Grind (in beans, out powder); flow grind::powder to brew::powder; bind brew::water = water; action brew : Brew (in powder, in water, out coffee); bind brew::coffee = coffee; } } The SysML 2 grammars adhere to the general upcoming SysML 2 specification (which is still under improvement currently). Actually these grammars represents a slight superset to the official SysML 2 standard. It is intended for parsing SysML 2-compliant models. Well-formedness checks are kept to a minimum, because we assume to parse correctly produced SysML 2 models only. MontiCore's SysML 2 is a language familiy that comes with a textual representation to describe SysML 2 diagrams with respect to the standard. SysML 2 covers ADs , BDDs , IBDs , PackageDiagrams , ParametricDiagrams , RequirementDiagrams , SDs , SMDs , UseCaseDiagrams , and general SysMLBasics Main grammars and detailed description","title":"SysML_2 (Alpha: Intention to become stable)"},{"location":"docs/Languages/#tagging-alpha-intention-to-become-stable","text":"Caretaker: SVa Tags are known e.g. from the UML and SysML and mainly used to add extra information to a model element. Normally tags (and stereotypes ) are inserted within the models, which over time polutes the models, especially when different sets of tags are needed for different technical platforms. MontiCore offers a solution that separates a model and its tags into distinct artifacts . Several independent tagging artifacts can be added without any need to adapt the core model. This allows fo reuse even of fixed library models. The tagging artifacts are dependent on two factors: First, tags can be added to named elements of the base model. It is of great help that we have an elegant symbol mechanism included in the MontiCore generator. Second, the set of allowed tags can be constrained, by an explicit definition of allowed tag types and tag values and an explicit declaration on which kinds of symbols a tag may be attached to. Consequently tagging is not a single language, but a method to automatically and schematically derive languages: A tagging schema language TSL (dependent on the available symbol types of the base grammar) a tagging language TL (dependent on the tag schema models written in TSL) Because tagging models can e.g. be used as configuration techniques in a code generator, appropriate infrastructure is generated as well. Some tagging language examples Although concrete languages (and their grammars) are themselves generated, there is a main grammar ocl.monticore.lang.Tagging , where the tagging language is derived from. See also detailed description","title":"Tagging (Alpha: Intention to become stable)"},{"location":"docs/Languages/#xml-alpha-intention-to-become-stable","text":"Responsible: NJ The MontiCore language for parsing XML artifacts. An example: <Calendar> <Appointment name=\"lunch\"> <Date>24.04.2020</Date> <Time>11:30</Time> <Location>cafeteria</Location> </Appointment> </Calendar> The XML grammar adheres to the common XML standard and allows parsing arbitrary XML artifacts for further processing. Actually the grammar represents a slight superset to the official XML standard. It is intended for parsing XML-compliant artifacts. Further well-formedness checks are not included, because we assume to parse correctly produced XML documents only. Please note that XML (like JSON or ASCII) is mainly a carrier language. The concrete XML dialect and the question, how to recreate the real objects / data structures, etc. behind the XML structure is beyond this grammar, but can be applied to the AST defined here. Main grammar de.monticore.lang.XML and detailed description","title":"XML (Alpha: Intention to become stable)"},{"location":"docs/Languages/#javalight-beta-in-stabilization","text":"Caretaker: MB This is a reduced version of the Java language . JavaLight is meant to be used to integrate simplified Java-like parts in modeling languages but not to parse complete Java implementations. It provides Java's attribute and method definitions , statements and expressions , but does not provide class or interface definitions and also no wildcards in the type system. One main usage of JavaLight is in the Grammar-language to model e.g. Java methods. An example: public void print(String name) { System.out.println(\"Hello \" + name); } [Main grammar de.monticore.JavaLight ]((https://git.rwth-aachen.de/monticore/monticore/blob/dev/monticore-grammar/src/main/grammars/de/monticore/JavaLight.mc4) and detailed description .","title":"JavaLight (Beta: In Stabilization)"},{"location":"docs/Languages/#java-beta-in-stabilization-30-to-mc6","text":"Caretaker: MB This is the full Java' Language (as Opposed to JavaLight). Main Grammar JavaDSL and detailed description .","title":"Java (Beta: In Stabilization) (30% to MC6)"},{"location":"docs/Languages/#further-information","text":"Project root: MontiCore @github MontiCore documentation Licence definition","title":"Further Information"},{"location":"docs/Publications/","text":"Redirecting to https://www.se-rwth.de/topics/MontiCore.php","title":"Publications"},{"location":"docs/further_docs/Impressum/","text":"Impressum According to German law, each website needs to have an \"impressum\", declaring among other things who is responsible for the content. A few things are currently unclear: Is only github (in total) a website or each group withing github, or each project? What if the project is open source, do then all (German) contributors have to add an impressum? If the webpage is hosted outside Germany (like github), does German law then apply at all? Although a lot of things are unclear and the text below doesn't totally fit, we have opted to be on the safe side and add our Impressum below. Please note that this is an open source project and each contributor may change any artifact of the project -- even this text -- so we do not claim any responsibility or credits for the project, even so we are currently having the role of the curators . Herausgeberin Herausgegeben im Auftrag des Rektors der Rheinisch-Westf\u00e4lischen Technischen Hochschule (RWTH) Aachen. RWTH Aachen \\ Templergraben 55 52062 Aachen (Hausanschrift) \\ 52056 Aachen (Postanschrift) Telefon: +49 241 80 1 \\ Telefax: +49 241 80 92312 Internet: www.rwth-aachen.de Die RWTH Aachen ist eine K\u00f6rperschaft des \u00f6ffentlichen Rechts. Sie wird durch den Dr. rer. nat. Dr. h. c. mult. Ulrich R\u00fcdiger vertreten. Zust\u00e4ndige Aufsichtsbeh\u00f6rde Ministerium f\u00fcr Kultur und Wissenschaft des Landes Nordrhein Westfalen, V\u00f6lklinger Stra\u00dfe 49, 40221 D\u00fcsseldorf. Umsatzsteuer-Identifikationsnummer Gem\u00e4\u00df Par. 27 a Umsatzsteuergesetz: DE 121689807 Inhaltliche Verantwortlichkeit Webmaster / Webredaktion: \\ Bernhard Rumpe \\ E-Mail: webmaster@se-rwth.de Die Webseiten der Zentralen Hochschulverwaltung, der Zentralen Einrichtungen, der Gruppenvertretungen, der Institute, Lehrst\u00fchle sowie Lehr- und Forschungsgebiete werden von den von diesen beauftragten Webkoordinatorinnen und Webkoordinatoren beziehungsweise deren Webmastern eigenst\u00e4ndig betreut. Details zu Fragen der Haftung sind in der Datenschutzerkl\u00e4rung nachzulesen.","title":"Impressum"},{"location":"docs/further_docs/Impressum/#impressum","text":"According to German law, each website needs to have an \"impressum\", declaring among other things who is responsible for the content. A few things are currently unclear: Is only github (in total) a website or each group withing github, or each project? What if the project is open source, do then all (German) contributors have to add an impressum? If the webpage is hosted outside Germany (like github), does German law then apply at all? Although a lot of things are unclear and the text below doesn't totally fit, we have opted to be on the safe side and add our Impressum below. Please note that this is an open source project and each contributor may change any artifact of the project -- even this text -- so we do not claim any responsibility or credits for the project, even so we are currently having the role of the curators .","title":"Impressum"},{"location":"docs/further_docs/Impressum/#herausgeberin","text":"Herausgegeben im Auftrag des Rektors der Rheinisch-Westf\u00e4lischen Technischen Hochschule (RWTH) Aachen. RWTH Aachen \\ Templergraben 55 52062 Aachen (Hausanschrift) \\ 52056 Aachen (Postanschrift) Telefon: +49 241 80 1 \\ Telefax: +49 241 80 92312 Internet: www.rwth-aachen.de Die RWTH Aachen ist eine K\u00f6rperschaft des \u00f6ffentlichen Rechts. Sie wird durch den Dr. rer. nat. Dr. h. c. mult. Ulrich R\u00fcdiger vertreten.","title":"Herausgeberin"},{"location":"docs/further_docs/Impressum/#zustandige-aufsichtsbehorde","text":"Ministerium f\u00fcr Kultur und Wissenschaft des Landes Nordrhein Westfalen, V\u00f6lklinger Stra\u00dfe 49, 40221 D\u00fcsseldorf.","title":"Zust\u00e4ndige Aufsichtsbeh\u00f6rde"},{"location":"docs/further_docs/Impressum/#umsatzsteuer-identifikationsnummer","text":"Gem\u00e4\u00df Par. 27 a Umsatzsteuergesetz: DE 121689807","title":"Umsatzsteuer-Identifikationsnummer"},{"location":"docs/further_docs/Impressum/#inhaltliche-verantwortlichkeit","text":"Webmaster / Webredaktion: \\ Bernhard Rumpe \\ E-Mail: webmaster@se-rwth.de Die Webseiten der Zentralen Hochschulverwaltung, der Zentralen Einrichtungen, der Gruppenvertretungen, der Institute, Lehrst\u00fchle sowie Lehr- und Forschungsgebiete werden von den von diesen beauftragten Webkoordinatorinnen und Webkoordinatoren beziehungsweise deren Webmastern eigenst\u00e4ndig betreut. Details zu Fragen der Haftung sind in der Datenschutzerkl\u00e4rung nachzulesen.","title":"Inhaltliche Verantwortlichkeit"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/","text":"MontiCore Core Grammars - an Overview MontiCore is a language workbench. It uses grammars as primary mechanism to describe DSLs. The extended grammar format allows to compose language components by (1) inheriting , (2) extending , (3) embedding and (4) aggregating grammars (see the reference manual for details). From the grammars a lot of infrastructructure is generated, that is as well composable , can be extended with handwrittten code and most importandly, these extensions and the grammar composition are compatible, which leads to optimal forms of reuse . The following is a list of language components, mainly defined through a primary grammar plus associated Java- and Template-Files, available in the MontiCore core project together with short descriptions and their status ( Status of Grammars ). The list covers the core grammars to be found in the MontiCore/monticore project under monticore-grammar/src/main/grammars/ in packages de.monticore de.monticore.expressions de.monticore.literals de.monticore.statements de.monticore.types For more langauges, see here . Table of Contents: [[ TOC ]] General: List of Grammars in package de.monticore MCBasics.mc4 (stable) This grammar defines absolute basics, such as spaces, Java-like comments and Names. It should be useful in many languages. Types: List of Grammars in package de.monticore.types These grammars generally deal with type definitions and build on each other. Some snipets for type definitions: MCBasicTypes boolean byte short int long char float double void Person a.b.Person import a.b.Foo.*; MCCollectionTypes List<.> Set<.> Optional<.> Map<.,.> MCSimpleGenericTypes Foo<.> a.b.Bar<.,..,.> MCFullGenericTypes Foo<? extends .> Foo<? super .> Person[] MCBasicTypes.mc4 (stable) This grammar defines basic types. This eases the reuse of type structures in languages similar to Java, that are somewhat simplified, e.g. without generics. The grammar contains types from Java, e.g., primitives, void, classes (also sometimes called \"reference types\"). MCCollectionTypes.mc4 (stable) This grammar defines four generics: List<A> , Map<A,B> , Set<A> and Optional<A> on top of basic types. These four generics correspond to a typical predefined set of generic types for example used in connection with UML class diagrams or the OCL. UML associations typically have those association multiplicities and therefore these types are of interest. This eases the reuse of type structures in languages similar to Java, that are somewhat simplified, e.g. without general generics. MCSimpleGenericTypes.mc4 (stable) This grammar introduces freely defined generic types such as Blubb<A> , Bla<B,C> , Foo<Blubb<D>> These generics are covering a wide range of uses for generic types, although they don't cover type restrictions on the arguments, like in Java. MCFullGenericTypes.mc4 (Beta: In Stabilization) This grammar completes the type definitions to support the full Java type system including wildcards Blubb<? extends A> A general advice: When you are not sure that you need this kind of types, then use a simpler version from above. Type checking ist tricky. BasicTypeSymbols.mc4 (Beta: In Stabilization) This grammar defines symbols for Types (of all kinds), Functions , Variables and TypeVariables . The defined symbols are of general form and can be used in functional, OO and other contexts. They do not preculde a concrete syntax and do not yet embody OO specifics. Remark: This grammar is not intended to define concrete or abstract syntax, but the infrastructure for symbols. TypeSymbols.mc4 (Beta: In Stabilization) This grammar defines symbols for objectoriented Types , Methods , and Fields by mainly extending the symbols defined in BasicTypeSymbols . The newly defined symbols extend the general ones by typical objectoriented features, such as private, static, etc. Again they do not preculde a concrete syntax. Remark: This grammar is not intended to define concrete or abstract syntax, but the infrastructure for symbols in objectoriented context. Expressions: List of Grammars in package de.monticore.expressions Expressions are defined in several grammars forming a (nonlinear) hierarchy, so that developers can choose the optimal grammar they want to build on for their language and combine these with the appropriate typing infrastructure. This modularity of expressions and associated types greatly eases the reuse of type structures in languages similar to Java. Some snipets for operators definrd in expressions: CommonExp: / % + - <= >= == > < != ~. !. .?.:. PLogicExp: && || ~. AssigementExp: ++ -- = += -= *= /= &= |= ^= >>= >>>= <<= %= BitExp: & | ^ << >> >>> OclExp: implies <=> | & forall exists let.in. .@pre .[.] .** Set{.|.} JavaClass: this .[.] (.). super .instanceof. SetExp: .isin. .in. union intersect setand setor ExpressionsBasis.mc4 (stable) This grammar defines core interfaces for expressions and imports the kinds of symbols necessary. The symbols are taken over from the TypeSymbols grammar (see below). A hierarchy of conservative extensions to this grammar realize these interfaces in various forms. CommonExpressions.mc4 (stable) This grammar defines a typical standard set of operations for expressions. This is a subset of Java as well as OCL/P, mainly for arithmetic, comparisons, variable use (v), attribute use (o.att), method call (foo(arg,arg2)) and brackets (exp). BitExpressions.mc4 (stable) This grammar defines a typical standard set of operations for expressions. This is a subset of Java for binary expressions like <<, >>, >>>, &, ^ and | AssignmentExpressions.mc4 (stable) This grammar defines all Java expressions that have side effects. This includes assignment expressions like =, +=, etc. and suffix and prefix expressions like ++, --, etc. JavaClassExpressions.mc4 (stable) This grammar defines Java specific class expressions like super, this, type cast, etc. This grammar should only be included, when a mapping to Java is intended and the full power of Java should be available in the modelling language. SetExpressions.mc4 (Beta: In Stabilization) This grammar defines set expressions like {..|..}, set union, intersection etc. these operations are typical for a logic with set operations, like UML's OCL. OCLExpressions.mc4 (Alpha: Needs restructuring) This grammar defines a expressions typical to UMLs OCL . This grammar will be restructured. Especially the non expression part of the OCL will be separated. Literals: List of Grammars in package de.monticore.literals Literals are the basic elements of expressions, such as numbers, strings, truth values. Some snipets: MCCommonLit 3 -3 2.17 -4 true false 'c' '\\03AE' 3L 2.17d 2.17f 0xAF \"string\" \"str\\b\\n\\\\\" \"str\\uAF01\\u0001\\377\" null MCJavaLiterals 999_999 0x3F2A 0b0001_0101 0567 1.2e-7F MCLiteralsBasis.mc4 (stable) This grammar defines core interface for literals. Several conservative extensions to this grammar realize various forms of literals. MCCommonLiterals.mc4 (stable) This grammar defines the typical literals for an expression language, such as characters: 'c', Strings \"text\", booleans: \"true\", \"null\", or numbers 10, -23, 48l, 23.1f. Strings and characters use the Java-like escapes like \"\\n\". Each defined nonterminal is extended by a conversion function getValue() of appropriate type and a retrieve function getSource() for a text representation of the literal. MCJavaLiterals.mc4 (Beta: In Stabilization) This grammar defines Java compliant literals and builds on MCCommonLiterals. The scope of this grammar is to ease the reuse of literals structures in Java-like sublanguages. The grammar contains literals from Java, e.g., Boolean, Char, String, .... Please note that Java (and this grammar) has an extended syntax e.g. for integers using underscores or other kinds of encodings. They parse e.g. 999_999, 0x3F2A, or 0b10100. Like above getValue() and getSource() allow to retrive the content as value resp. as text string. Statements: List of Grammars in package de.monticore.statements Statements are the constructive part of programs: They allow to change variables, call functions, send messages etc. The following hierarchy of statement definitions should allow the developers to choose needed forms of statements and extend it by their own additional needs. The provided list of statements is inspired by Java (actually subset of Java). Some example statements: int i; int j = 2; Person p[] = { foo(3+7), p2, ...} if (.) then . else . for ( i = .; .; .) {.} while (.) . do . while (.) switch (.) { case .: .; default: .} foo(1,2,3) return . assert . : \"...\" try {.} catch (.) {.} finally {.} throw . break . continue . label: private static final native ... MCStatementsBasis.mc4 (stable) This grammar defines the core interface for statements. A hierarchy of conservative extensions to this grammar is provided below. MCCommonStatements.mc4 (Beta: In Stabilization) This grammar defines typical statements, such as method calls (which are actually expressions), assignment of variables, if, for, while, switch statements, and blocks. This embodies a complete structured statement language, however does not provide return, assert, exceptions, and low-level constructs like break. MCAssertStatements.mc4 (stable) This grammar defines exactly the assert statement as known from Java. It can be used independently of other Java statements. MCExceptionStatements.mc4 (Beta: In Stabilization) This grammar defines the exception statements. This includes Java try with catch and finally, as well as throw. MCSynchronizedStatements.mc4 (stable) This grammar defines the Java-like synchronized statement. MCLowLevelStatements.mc4 (Beta: In Stabilization) This grammar defines three low-level statements that Java provides. It contains the break and continue statements and the possibility to label a statement. MCReturnStatements.mc4 (stable) This grammar defines the Java-like return statement. MCFullJavaStatements.mc4 (stable) This grammar defines all Java statements. This is neither a generalized approximation nor a restricted overapproximation, but exact. Further grammars in package de.monticore several smaller grammars are also available: Cardinality.mc4 (stable) This grammar defines UML Cardinalities of forms * , [n..m] or [n..*] . Completeness.mc4 (stable) This grammar defines completeness information in UML like ... , (c) , but also (...,c) . UMLModifier.mc4 (stable) The grammar contains the modifiers that UML provides. This includes public private , protected , final , abstract , local , derived , readonly , and static , but also the compact syntactic versions + , # , - , / and ? (for readonly). UML modifiers are not identical to Java modifiers (e.g. native or threadsafe are missing.) UMLStereotype.mc4 (stable) This grammars defines Stereotypes like <<val1,val2=\"text\",...>> Methods contains(name), getValue(name) assist Stereotype retrieval. Values may only be of type String. The real value unfortunately in UML is only encoded as String. We suggest to use a tagging infrastructure that even allows to type the possible forms of tags. MCCommon.mc4 (stable) This grammar composes typical UML like grammar components. This includes Cardinality, Completeness, UMLModifier, and UMLStereotype. JavaLight.mc4 (Beta: In Stabilization) JavaLight is a subset of Java that MontiCore itself uses as intermediate language for the code generation process. JavaLight doesn't provide all forms of classes (e.g. inner classes) and reduces the type system to normal generic types. However, that is suffiecient for representation of all generated pieces of code that MontiCore wants to make. JavaLight can be used for other generator tools as well, especially as core template are reusable and new templates for specific method bodies can be added using MontiCore's Hook-Mechanisms. Examples for Grammars under monticore-grammar/src/main/examples These can also be used if someone is interested: StringLiterals.mc4 MCHexNumbers.mc4 MCNumbers.mc4 Further Information Project root: MontiCore @github List of languages . MontiCore documentation","title":"General"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#monticore-core-grammars-an-overview","text":"MontiCore is a language workbench. It uses grammars as primary mechanism to describe DSLs. The extended grammar format allows to compose language components by (1) inheriting , (2) extending , (3) embedding and (4) aggregating grammars (see the reference manual for details). From the grammars a lot of infrastructructure is generated, that is as well composable , can be extended with handwrittten code and most importandly, these extensions and the grammar composition are compatible, which leads to optimal forms of reuse . The following is a list of language components, mainly defined through a primary grammar plus associated Java- and Template-Files, available in the MontiCore core project together with short descriptions and their status ( Status of Grammars ). The list covers the core grammars to be found in the MontiCore/monticore project under monticore-grammar/src/main/grammars/ in packages de.monticore de.monticore.expressions de.monticore.literals de.monticore.statements de.monticore.types For more langauges, see here . Table of Contents: [[ TOC ]]","title":"MontiCore Core Grammars - an Overview"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#general-list-of-grammars-in-package-demonticore","text":"","title":"General: List of Grammars in package de.monticore"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcbasicsmc4-stable","text":"This grammar defines absolute basics, such as spaces, Java-like comments and Names. It should be useful in many languages.","title":"MCBasics.mc4  (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#types-list-of-grammars-in-package-demonticoretypes","text":"These grammars generally deal with type definitions and build on each other. Some snipets for type definitions: MCBasicTypes boolean byte short int long char float double void Person a.b.Person import a.b.Foo.*; MCCollectionTypes List<.> Set<.> Optional<.> Map<.,.> MCSimpleGenericTypes Foo<.> a.b.Bar<.,..,.> MCFullGenericTypes Foo<? extends .> Foo<? super .> Person[]","title":"Types: List of Grammars in package de.monticore.types"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcbasictypesmc4-stable","text":"This grammar defines basic types. This eases the reuse of type structures in languages similar to Java, that are somewhat simplified, e.g. without generics. The grammar contains types from Java, e.g., primitives, void, classes (also sometimes called \"reference types\").","title":"MCBasicTypes.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mccollectiontypesmc4-stable","text":"This grammar defines four generics: List<A> , Map<A,B> , Set<A> and Optional<A> on top of basic types. These four generics correspond to a typical predefined set of generic types for example used in connection with UML class diagrams or the OCL. UML associations typically have those association multiplicities and therefore these types are of interest. This eases the reuse of type structures in languages similar to Java, that are somewhat simplified, e.g. without general generics.","title":"MCCollectionTypes.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcsimplegenerictypesmc4-stable","text":"This grammar introduces freely defined generic types such as Blubb<A> , Bla<B,C> , Foo<Blubb<D>> These generics are covering a wide range of uses for generic types, although they don't cover type restrictions on the arguments, like in Java.","title":"MCSimpleGenericTypes.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcfullgenerictypesmc4-beta-in-stabilization","text":"This grammar completes the type definitions to support the full Java type system including wildcards Blubb<? extends A> A general advice: When you are not sure that you need this kind of types, then use a simpler version from above. Type checking ist tricky.","title":"MCFullGenericTypes.mc4 (Beta: In Stabilization)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#basictypesymbolsmc4-beta-in-stabilization","text":"This grammar defines symbols for Types (of all kinds), Functions , Variables and TypeVariables . The defined symbols are of general form and can be used in functional, OO and other contexts. They do not preculde a concrete syntax and do not yet embody OO specifics. Remark: This grammar is not intended to define concrete or abstract syntax, but the infrastructure for symbols.","title":"BasicTypeSymbols.mc4 (Beta: In Stabilization)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#typesymbolsmc4-beta-in-stabilization","text":"This grammar defines symbols for objectoriented Types , Methods , and Fields by mainly extending the symbols defined in BasicTypeSymbols . The newly defined symbols extend the general ones by typical objectoriented features, such as private, static, etc. Again they do not preculde a concrete syntax. Remark: This grammar is not intended to define concrete or abstract syntax, but the infrastructure for symbols in objectoriented context.","title":"TypeSymbols.mc4 (Beta: In Stabilization)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#expressions-list-of-grammars-in-package-demonticoreexpressions","text":"Expressions are defined in several grammars forming a (nonlinear) hierarchy, so that developers can choose the optimal grammar they want to build on for their language and combine these with the appropriate typing infrastructure. This modularity of expressions and associated types greatly eases the reuse of type structures in languages similar to Java. Some snipets for operators definrd in expressions: CommonExp: / % + - <= >= == > < != ~. !. .?.:. PLogicExp: && || ~. AssigementExp: ++ -- = += -= *= /= &= |= ^= >>= >>>= <<= %= BitExp: & | ^ << >> >>> OclExp: implies <=> | & forall exists let.in. .@pre .[.] .** Set{.|.} JavaClass: this .[.] (.). super .instanceof. SetExp: .isin. .in. union intersect setand setor","title":"Expressions: List of Grammars in package de.monticore.expressions"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#expressionsbasismc4-stable","text":"This grammar defines core interfaces for expressions and imports the kinds of symbols necessary. The symbols are taken over from the TypeSymbols grammar (see below). A hierarchy of conservative extensions to this grammar realize these interfaces in various forms.","title":"ExpressionsBasis.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#commonexpressionsmc4-stable","text":"This grammar defines a typical standard set of operations for expressions. This is a subset of Java as well as OCL/P, mainly for arithmetic, comparisons, variable use (v), attribute use (o.att), method call (foo(arg,arg2)) and brackets (exp).","title":"CommonExpressions.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#bitexpressionsmc4-stable","text":"This grammar defines a typical standard set of operations for expressions. This is a subset of Java for binary expressions like <<, >>, >>>, &, ^ and |","title":"BitExpressions.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#assignmentexpressionsmc4-stable","text":"This grammar defines all Java expressions that have side effects. This includes assignment expressions like =, +=, etc. and suffix and prefix expressions like ++, --, etc.","title":"AssignmentExpressions.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#javaclassexpressionsmc4-stable","text":"This grammar defines Java specific class expressions like super, this, type cast, etc. This grammar should only be included, when a mapping to Java is intended and the full power of Java should be available in the modelling language.","title":"JavaClassExpressions.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#setexpressionsmc4-beta-in-stabilization","text":"This grammar defines set expressions like {..|..}, set union, intersection etc. these operations are typical for a logic with set operations, like UML's OCL.","title":"SetExpressions.mc4 (Beta: In Stabilization)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#oclexpressionsmc4-alpha-needs-restructuring","text":"This grammar defines a expressions typical to UMLs OCL . This grammar will be restructured. Especially the non expression part of the OCL will be separated.","title":"OCLExpressions.mc4 (Alpha: Needs restructuring)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#literals-list-of-grammars-in-package-demonticoreliterals","text":"Literals are the basic elements of expressions, such as numbers, strings, truth values. Some snipets: MCCommonLit 3 -3 2.17 -4 true false 'c' '\\03AE' 3L 2.17d 2.17f 0xAF \"string\" \"str\\b\\n\\\\\" \"str\\uAF01\\u0001\\377\" null MCJavaLiterals 999_999 0x3F2A 0b0001_0101 0567 1.2e-7F","title":"Literals: List of Grammars in package de.monticore.literals"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcliteralsbasismc4-stable","text":"This grammar defines core interface for literals. Several conservative extensions to this grammar realize various forms of literals.","title":"MCLiteralsBasis.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mccommonliteralsmc4-stable","text":"This grammar defines the typical literals for an expression language, such as characters: 'c', Strings \"text\", booleans: \"true\", \"null\", or numbers 10, -23, 48l, 23.1f. Strings and characters use the Java-like escapes like \"\\n\". Each defined nonterminal is extended by a conversion function getValue() of appropriate type and a retrieve function getSource() for a text representation of the literal.","title":"MCCommonLiterals.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcjavaliteralsmc4-beta-in-stabilization","text":"This grammar defines Java compliant literals and builds on MCCommonLiterals. The scope of this grammar is to ease the reuse of literals structures in Java-like sublanguages. The grammar contains literals from Java, e.g., Boolean, Char, String, .... Please note that Java (and this grammar) has an extended syntax e.g. for integers using underscores or other kinds of encodings. They parse e.g. 999_999, 0x3F2A, or 0b10100. Like above getValue() and getSource() allow to retrive the content as value resp. as text string.","title":"MCJavaLiterals.mc4 (Beta: In Stabilization)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#statements-list-of-grammars-in-package-demonticorestatements","text":"Statements are the constructive part of programs: They allow to change variables, call functions, send messages etc. The following hierarchy of statement definitions should allow the developers to choose needed forms of statements and extend it by their own additional needs. The provided list of statements is inspired by Java (actually subset of Java). Some example statements: int i; int j = 2; Person p[] = { foo(3+7), p2, ...} if (.) then . else . for ( i = .; .; .) {.} while (.) . do . while (.) switch (.) { case .: .; default: .} foo(1,2,3) return . assert . : \"...\" try {.} catch (.) {.} finally {.} throw . break . continue . label: private static final native ...","title":"Statements: List of Grammars in package de.monticore.statements"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcstatementsbasismc4-stable","text":"This grammar defines the core interface for statements. A hierarchy of conservative extensions to this grammar is provided below.","title":"MCStatementsBasis.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mccommonstatementsmc4-beta-in-stabilization","text":"This grammar defines typical statements, such as method calls (which are actually expressions), assignment of variables, if, for, while, switch statements, and blocks. This embodies a complete structured statement language, however does not provide return, assert, exceptions, and low-level constructs like break.","title":"MCCommonStatements.mc4 (Beta: In Stabilization)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcassertstatementsmc4-stable","text":"This grammar defines exactly the assert statement as known from Java. It can be used independently of other Java statements.","title":"MCAssertStatements.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcexceptionstatementsmc4-beta-in-stabilization","text":"This grammar defines the exception statements. This includes Java try with catch and finally, as well as throw.","title":"MCExceptionStatements.mc4 (Beta: In Stabilization)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcsynchronizedstatementsmc4-stable","text":"This grammar defines the Java-like synchronized statement.","title":"MCSynchronizedStatements.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mclowlevelstatementsmc4-beta-in-stabilization","text":"This grammar defines three low-level statements that Java provides. It contains the break and continue statements and the possibility to label a statement.","title":"MCLowLevelStatements.mc4 (Beta: In Stabilization)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcreturnstatementsmc4-stable","text":"This grammar defines the Java-like return statement.","title":"MCReturnStatements.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcfulljavastatementsmc4-stable","text":"This grammar defines all Java statements. This is neither a generalized approximation nor a restricted overapproximation, but exact.","title":"MCFullJavaStatements.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#further-grammars-in-package-demonticore","text":"several smaller grammars are also available:","title":"Further grammars in package de.monticore"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#cardinalitymc4-stable","text":"This grammar defines UML Cardinalities of forms * , [n..m] or [n..*] .","title":"Cardinality.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#completenessmc4-stable","text":"This grammar defines completeness information in UML like ... , (c) , but also (...,c) .","title":"Completeness.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#umlmodifiermc4-stable","text":"The grammar contains the modifiers that UML provides. This includes public private , protected , final , abstract , local , derived , readonly , and static , but also the compact syntactic versions + , # , - , / and ? (for readonly). UML modifiers are not identical to Java modifiers (e.g. native or threadsafe are missing.)","title":"UMLModifier.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#umlstereotypemc4-stable","text":"This grammars defines Stereotypes like <<val1,val2=\"text\",...>> Methods contains(name), getValue(name) assist Stereotype retrieval. Values may only be of type String. The real value unfortunately in UML is only encoded as String. We suggest to use a tagging infrastructure that even allows to type the possible forms of tags.","title":"UMLStereotype.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mccommonmc4-stable","text":"This grammar composes typical UML like grammar components. This includes Cardinality, Completeness, UMLModifier, and UMLStereotype.","title":"MCCommon.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#javalightmc4-beta-in-stabilization","text":"JavaLight is a subset of Java that MontiCore itself uses as intermediate language for the code generation process. JavaLight doesn't provide all forms of classes (e.g. inner classes) and reduces the type system to normal generic types. However, that is suffiecient for representation of all generated pieces of code that MontiCore wants to make. JavaLight can be used for other generator tools as well, especially as core template are reusable and new templates for specific method bodies can be added using MontiCore's Hook-Mechanisms.","title":"JavaLight.mc4 (Beta: In Stabilization)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#examples-for-grammars-under-monticore-grammarsrcmainexamples","text":"These can also be used if someone is interested: StringLiterals.mc4 MCHexNumbers.mc4 MCNumbers.mc4","title":"Examples for Grammars under monticore-grammar/src/main/examples"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#further-information","text":"Project root: MontiCore @github List of languages . MontiCore documentation","title":"Further Information"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/","text":"JavaLight JavaLight is a subset of Java. JavaLight provides methods, a subset of statments and expressions and basic types. It is possible to enrich the language with more complex types, expressions and statements. The grammar file is de.monticore.JavaLight . Example public void print(String name) { System.out.println(\"Hello \" + name); } The example shows a simple method with one parameter. Some statements (statements for exception handling, continue- and break-statement, etc.) are not supported. But is it possible to extend the language accordingly. Parser JavaLight is a component grammar, no parser is generated Symboltable JavaLight introduces the MethOrConstrSymbol extending TypeSymbols.MethodSymbol. The symbol receives the additional attributes: annotations exceptions isEllipsisParameterMethod isFinal isAbstract isSynchronized isNative isStrictfp A VarDeclSymbol is created for formal parameters and variable declarations. The VarDeclSymbol is defined in MCVarDeclarationStatements and extends TypeSymbols.Field. Functionality CoCos PrettyPrinter The basic pretty printer for JavaLight is de.monticore.prettyprint.JavaLightPrettyPrinter","title":"JavaLight"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#javalight","text":"JavaLight is a subset of Java. JavaLight provides methods, a subset of statments and expressions and basic types. It is possible to enrich the language with more complex types, expressions and statements. The grammar file is de.monticore.JavaLight .","title":"JavaLight"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#example","text":"public void print(String name) { System.out.println(\"Hello \" + name); } The example shows a simple method with one parameter. Some statements (statements for exception handling, continue- and break-statement, etc.) are not supported. But is it possible to extend the language accordingly.","title":"Example"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#parser","text":"JavaLight is a component grammar, no parser is generated","title":"Parser"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#symboltable","text":"JavaLight introduces the MethOrConstrSymbol extending TypeSymbols.MethodSymbol. The symbol receives the additional attributes: annotations exceptions isEllipsisParameterMethod isFinal isAbstract isSynchronized isNative isStrictfp A VarDeclSymbol is created for formal parameters and variable declarations. The VarDeclSymbol is defined in MCVarDeclarationStatements and extends TypeSymbols.Field.","title":"Symboltable"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#functionality","text":"","title":"Functionality"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#cocos","text":"","title":"CoCos"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#prettyprinter","text":"The basic pretty printer for JavaLight is de.monticore.prettyprint.JavaLightPrettyPrinter","title":"PrettyPrinter"},{"location":"monticore-grammar/src/main/grammars/de/monticore/expressions/Expressions/","text":"MontiCore - Expression-Language Modules MC-Expressions are used to formulate mathematical and programmatic expressions of a set of literals. To achieve this, a system of modular and pluggable grammar parts are developed. Given Expression languages in MontiCore Currently, there are seven expression languages. These are ExpressionsBasis (basis for all of the expression languages, supports names and literals) AssignmentExpressions (extends ExpressionsBasis, basic assignments) CommonExpressions (extends ExpressionsBasis, common expressions like + and -) BitExpressions (extends ExpressionsBasis, bit expressions like & or <<) SetExpressions (extends ExpressionsBasis, ideal for working with sets) OCLExpressions (extends ExpressionsBasis, introduces OCL to MontiCore) JavaClassExpressions (extends CommonExpressions, adds Java expressions like new) Using Expressions If you want to use one (or more) of the given expression languages in your language, then all you have to do is extend it (or them) in your grammar. You are free to use any of them now. Creating your own Expression language There are some expressions you need desperately and that are not covered in the given expression languages? Create a new grammar that extends at least ExpressionsBasis. In this grammar, you can add your own expressions. These expressions must implement the interface Expression in the ExpressionsBasis grammar. To include these expressions in your language, just extend the new grammar in your language. See here for an example.","title":"Expressions"},{"location":"monticore-grammar/src/main/grammars/de/monticore/expressions/Expressions/#monticore-expression-language-modules","text":"MC-Expressions are used to formulate mathematical and programmatic expressions of a set of literals. To achieve this, a system of modular and pluggable grammar parts are developed.","title":"MontiCore - Expression-Language Modules"},{"location":"monticore-grammar/src/main/grammars/de/monticore/expressions/Expressions/#given-expression-languages-in-monticore","text":"Currently, there are seven expression languages. These are ExpressionsBasis (basis for all of the expression languages, supports names and literals) AssignmentExpressions (extends ExpressionsBasis, basic assignments) CommonExpressions (extends ExpressionsBasis, common expressions like + and -) BitExpressions (extends ExpressionsBasis, bit expressions like & or <<) SetExpressions (extends ExpressionsBasis, ideal for working with sets) OCLExpressions (extends ExpressionsBasis, introduces OCL to MontiCore) JavaClassExpressions (extends CommonExpressions, adds Java expressions like new)","title":"Given Expression languages in MontiCore"},{"location":"monticore-grammar/src/main/grammars/de/monticore/expressions/Expressions/#using-expressions","text":"If you want to use one (or more) of the given expression languages in your language, then all you have to do is extend it (or them) in your grammar. You are free to use any of them now.","title":"Using Expressions"},{"location":"monticore-grammar/src/main/grammars/de/monticore/expressions/Expressions/#creating-your-own-expression-language","text":"There are some expressions you need desperately and that are not covered in the given expression languages? Create a new grammar that extends at least ExpressionsBasis. In this grammar, you can add your own expressions. These expressions must implement the interface Expression in the ExpressionsBasis grammar. To include these expressions in your language, just extend the new grammar in your language. See here for an example.","title":"Creating your own Expression language"},{"location":"monticore-grammar/src/main/grammars/de/monticore/literals/Literals/","text":"MontiCore - Literals Literals are the basis to parse Numbers, Strings and other atomic language elements. Modularization works as follows. 'MCLiteralBasis' defines the root nonterminal 'Literal', but no terminals with literal terms. Concrete terminal symbols are defined in MCCommonLiterals and MCJavaLiterals and can be included into a concrete language as desired. Grammar MCCommonLiterals.mc4 This Grammar includes rules to parse: 'null' - NullLiteral 'true' & 'false' - BooleanLiteral 'a', ... , 'Z' - CharLiteral '\"...\"' - StringLiteral '123' - NatLiteral '-13' - SignedNatLiteral '6L', '6l' - BasicLongLiteral '-6L', '-6l', '6L', '6l' - SignedBasicLongLiteral '1.2F', '1.2f' - BasicFloatLiteral '-1.2F', '-1.2f', '1.2F', '1.2f' - SignedBasicFloatLiteral Grammar MCJavaLiterals.mc4 This Grammar extends MCCommonLiterals.mc4 and includes rules to parse: '123','0734', '1001001', '0x1a' - IntLiteral '2L', '0734l', '1001001L', '0x1al' - LongLiteral '1.23F', '1.23E4f' - FloatLiteral '1.23', '1.23d', '1.23E4D' - DoubleLiteral","title":"Literals"},{"location":"monticore-grammar/src/main/grammars/de/monticore/literals/Literals/#monticore-literals","text":"Literals are the basis to parse Numbers, Strings and other atomic language elements. Modularization works as follows. 'MCLiteralBasis' defines the root nonterminal 'Literal', but no terminals with literal terms. Concrete terminal symbols are defined in MCCommonLiterals and MCJavaLiterals and can be included into a concrete language as desired.","title":"MontiCore - Literals"},{"location":"monticore-grammar/src/main/grammars/de/monticore/literals/Literals/#grammar-mccommonliteralsmc4","text":"This Grammar includes rules to parse: 'null' - NullLiteral 'true' & 'false' - BooleanLiteral 'a', ... , 'Z' - CharLiteral '\"...\"' - StringLiteral '123' - NatLiteral '-13' - SignedNatLiteral '6L', '6l' - BasicLongLiteral '-6L', '-6l', '6L', '6l' - SignedBasicLongLiteral '1.2F', '1.2f' - BasicFloatLiteral '-1.2F', '-1.2f', '1.2F', '1.2f' - SignedBasicFloatLiteral","title":"Grammar MCCommonLiterals.mc4"},{"location":"monticore-grammar/src/main/grammars/de/monticore/literals/Literals/#grammar-mcjavaliteralsmc4","text":"This Grammar extends MCCommonLiterals.mc4 and includes rules to parse: '123','0734', '1001001', '0x1a' - IntLiteral '2L', '0734l', '1001001L', '0x1al' - LongLiteral '1.23F', '1.23E4f' - FloatLiteral '1.23', '1.23d', '1.23E4D' - DoubleLiteral","title":"Grammar MCJavaLiterals.mc4"},{"location":"monticore-grammar/src/main/java/de/monticore/types/check/Types/","text":"In MontiCore, the TypeCheck is used to calculate the type of a set of expressions. This happens by traversing the AST of an expression, calculating the types of its sub-expressions and combining them to the type of the main expression. Given Classes in MontiCore TypeCheck (facade for using the TypeCheck) DeriveSymTypeOfExpression (calculate a type for the expressions in ExpressionsBasis) DeriveSymTypeOfCommonExpressions (calculate a type for the expressions in CommonExpressions) DeriveSymTypeOfAssignmentExpressions (calculate a type for the expressions in AssignmentExpressions) DeriveSymTypeOfBitExpressions (calculate a type for the expressions in BitExpressions) DeriveSymTypeOfLiterals (calculate a type for the literals in LiteralsBasis) DeriveSymTypeOfMCCommonLiterals (calculate a type for the literals in MCCommonLiterals) SynthesizeSymTypeFromMCBasicTypes (calculate a type for the types in MCBasicTypes) SynthesizeSymTypeFromMCCollectionTypes (calculate a type for the types in MCCollectionTypes) SynthesizeSymTypeFromMCSimpleGenericTypes (calculate a type for the types in MCSimpleGenericTypes) I want to write a CoCo for my language that uses the TypeCheck - How? You can use the TypeCheck facade. The facade needs a Derive-Class (for expressions and literals) and/or a Synthesize-Class (for types) and calculates the type of your given expressions/literals/types. Create a DelegatorVisitor which combines all expression grammars and literal grammars used by your language. The DelegatorVisitor has to implement the Interface ITypesCalculator. Use this Delegator as Derive-Class in the TypeCheck facade. The Synthesize-Class depends on the types grammar you use (see above-mentioned classes). For an example of the Delegator-Visitor see here . If you want to create a Derive-Class for your expression/literal grammar, you have to extend the Derive-Class of the supergrammar and implement the normal visitor of your language. There you can override the traverse methods for your expressions/literals so that it calculates the type of the expression/literal (see implementation in one of the above-mentioned classes). You can add your visitor to the DelegatorVisitor later on. For an example of a Derive-Class see here . Writing a CoCo to check the correctness of your type/expression/literal should be easy now that you have the TypeCheck facade to use. Just use the correct Derive-Class and/or the correct Synthesize-Class as parameters and check if the type of your expression or type is correctly calculated. Example for a CoCo: @Override public void check(ASTExpression expr){ YourDeriveClass deriveClass = new YourDeriveClass(...); //instance of your Derive-Class YourSynthesizeClass synthesizeClass = new YourSynthesizeClass(...); //instance of your Synthesize-Class TypeCheck check = new TypeCheck(synthesizeClass,deriveClass); //instance of the TypeCheck-facade, parameters are your Synthesize-Class and your Derive-Class if(\"double\"!=check.typeOf(expr).print()){ //test if your expression is of the correct type (here: double) Log.error(...); //your specified error message } }","title":"Types"},{"location":"monticore-grammar/src/main/java/de/monticore/types/check/Types/#given-classes-in-monticore","text":"TypeCheck (facade for using the TypeCheck) DeriveSymTypeOfExpression (calculate a type for the expressions in ExpressionsBasis) DeriveSymTypeOfCommonExpressions (calculate a type for the expressions in CommonExpressions) DeriveSymTypeOfAssignmentExpressions (calculate a type for the expressions in AssignmentExpressions) DeriveSymTypeOfBitExpressions (calculate a type for the expressions in BitExpressions) DeriveSymTypeOfLiterals (calculate a type for the literals in LiteralsBasis) DeriveSymTypeOfMCCommonLiterals (calculate a type for the literals in MCCommonLiterals) SynthesizeSymTypeFromMCBasicTypes (calculate a type for the types in MCBasicTypes) SynthesizeSymTypeFromMCCollectionTypes (calculate a type for the types in MCCollectionTypes) SynthesizeSymTypeFromMCSimpleGenericTypes (calculate a type for the types in MCSimpleGenericTypes)","title":"Given Classes in MontiCore"},{"location":"monticore-grammar/src/main/java/de/monticore/types/check/Types/#i-want-to-write-a-coco-for-my-language-that-uses-the-typecheck-how","text":"You can use the TypeCheck facade. The facade needs a Derive-Class (for expressions and literals) and/or a Synthesize-Class (for types) and calculates the type of your given expressions/literals/types. Create a DelegatorVisitor which combines all expression grammars and literal grammars used by your language. The DelegatorVisitor has to implement the Interface ITypesCalculator. Use this Delegator as Derive-Class in the TypeCheck facade. The Synthesize-Class depends on the types grammar you use (see above-mentioned classes). For an example of the Delegator-Visitor see here . If you want to create a Derive-Class for your expression/literal grammar, you have to extend the Derive-Class of the supergrammar and implement the normal visitor of your language. There you can override the traverse methods for your expressions/literals so that it calculates the type of the expression/literal (see implementation in one of the above-mentioned classes). You can add your visitor to the DelegatorVisitor later on. For an example of a Derive-Class see here . Writing a CoCo to check the correctness of your type/expression/literal should be easy now that you have the TypeCheck facade to use. Just use the correct Derive-Class and/or the correct Synthesize-Class as parameters and check if the type of your expression or type is correctly calculated. Example for a CoCo: @Override public void check(ASTExpression expr){ YourDeriveClass deriveClass = new YourDeriveClass(...); //instance of your Derive-Class YourSynthesizeClass synthesizeClass = new YourSynthesizeClass(...); //instance of your Synthesize-Class TypeCheck check = new TypeCheck(synthesizeClass,deriveClass); //instance of the TypeCheck-facade, parameters are your Synthesize-Class and your Derive-Class if(\"double\"!=check.typeOf(expr).print()){ //test if your expression is of the correct type (here: double) Log.error(...); //your specified error message } }","title":"I want to write a CoCo for my language that uses the TypeCheck - How?"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/","text":"Documentation of Symbol Table Runtime Classes","title":"Symboltable"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#documentation-of-symbol-table-runtime-classes","text":"","title":"Documentation of Symbol Table Runtime Classes"}]}